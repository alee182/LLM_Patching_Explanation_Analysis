[
    {

        "num": 1,
        "codeLink": "https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7",
        "CVE ID": "CVE-2018-13405",
        "CVE Details": "The inode_init_owner function in fs/inode.c in the Linux kernel through 3.16 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.",
        "CWE ID": "CWE-269",
        "commit_message": "Fix up non-directory creation in SGID directories\n\nsgid directories have special semantics, making newly created files in\nthe directory belong to the group of the directory, and newly created\nsubdirectories will also become sgid.  This is historically used for\ngroup-shared directories.\n\nBut group directories writable by non-group members should not imply\nthat such non-group members can magically join the group, so make sure\nto clear the sgid bit on non-directories for non-members (but remember\nthat sgid without group execute means \"mandatory locking\", just to\nconfuse things even more).\n\nReported-by: Jann Horn <jannh@google.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "fixed_function": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}\n",
        "vul_function": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}\n",
        "llama3.1 Summary": "The patch changes the behavior of newly created files and directories in SGID directories by clearing the S_ISGID bit for non-directories when created by non-group members. This change ensures that group directories writable by non-group members do not imply that such non-group members can join the group.",
        "llama3.1 CWE": "CWE-384",
        "llama3.1 CVE": "CVE-2018-1120",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5872",
            "BERTScore Recall": "0.5495",
            "BERTScore F1": "0.5677"
        },
        "llama3.1 Cosine_Similarity": 0.5370692014694214,
        "Mistral Summary": "The patch changes the behavior of creating files and subdirectories within SGID directories to ensure that the sgid bit is only set on directories and not on non-group members attempting to create non-directory files or subdirectories. This prevents potential privilege escalation vulnerabilities by enforcing proper group ownership and access control.",
        "Mistral CWE": "CWE-264 (Privilege Escalation or Root Hierarchy Traversal)",
        "Mistral CVE": "CVE-XXXX-XXXX (This will be assigned by the appropriate CVE Numbering Authority, as it is not provided in the information given)",
        "Mistral Cosine_Similarity": 0.4858046770095825,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5836",
            "BERTScore Recall": "0.5276",
            "BERTScore F1": "0.5542"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07",
        "CVE ID": "CVE-2018-6080",
        "CVE Details": "Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .",
        "CWE ID": "CWE-269",
        "commit_message": "memory-infra: split up memory-infra coordinator service into two\n\nThis allows for heap profiler to use its own service with correct\ncapabilities and all other instances to use the existing coordinator\nservice.\n\nBug: 792028\nChange-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd\nReviewed-on: https://chromium-review.googlesource.com/836896\nCommit-Queue: Lalit Maganti <lalitm@chromium.org>\nReviewed-by: Daniel Cheng <dcheng@chromium.org>\nReviewed-by: oysteine <oysteine@chromium.org>\nReviewed-by: Albert J. Wong <ajwong@chromium.org>\nReviewed-by: Hector Dearman <hjd@chromium.org>\nCr-Commit-Position: refs/heads/master@{#529059}",
        "fixed_function": "void ResourceCoordinatorService::OnStart() {\n  ref_factory_.reset(new service_manager::ServiceContextRefFactory(\n      base::Bind(&service_manager::ServiceContext::RequestQuit,\n                 base::Unretained(context()))));\n\n  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());\n\n  registry_.AddInterface(\n      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,\n                 base::Unretained(&introspector_)));\n\n  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();\n  registry_.AddInterface(\n      base::Bind(&PageSignalGeneratorImpl::BindToInterface,\n                 base::Unretained(page_signal_generator_impl.get())));\n  coordination_unit_manager_.RegisterObserver(\n      std::move(page_signal_generator_impl));\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<MetricsCollector>());\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<IPCVolumeReporter>(\n          std::make_unique<base::OneShotTimer>()));\n\n  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());\n  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());\n\n  memory_instrumentation_coordinator_ =\n      std::make_unique<memory_instrumentation::CoordinatorImpl>(\n          context()->connector());\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n  registry_.AddInterface(base::BindRepeating(\n      &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,\n      base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(\n      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,\n                          base::Unretained(tracing_agent_registry_.get())));\n\n  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();\n  registry_.AddInterface(\n      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,\n                          base::Unretained(tracing_coordinator_.get())));\n}\n",
        "vul_function": "void ResourceCoordinatorService::OnStart() {\n  ref_factory_.reset(new service_manager::ServiceContextRefFactory(\n      base::Bind(&service_manager::ServiceContext::RequestQuit,\n                 base::Unretained(context()))));\n\n  ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());\n\n  registry_.AddInterface(\n      base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,\n                 base::Unretained(&introspector_)));\n\n  auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();\n  registry_.AddInterface(\n      base::Bind(&PageSignalGeneratorImpl::BindToInterface,\n                 base::Unretained(page_signal_generator_impl.get())));\n  coordination_unit_manager_.RegisterObserver(\n      std::move(page_signal_generator_impl));\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<MetricsCollector>());\n\n  coordination_unit_manager_.RegisterObserver(\n      std::make_unique<IPCVolumeReporter>(\n          std::make_unique<base::OneShotTimer>()));\n\n  coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());\n  coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());\n\n  memory_instrumentation_coordinator_ =\n      std::make_unique<memory_instrumentation::CoordinatorImpl>(\n          context()->connector());\n   registry_.AddInterface(base::BindRepeating(\n       &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,\n       base::Unretained(memory_instrumentation_coordinator_.get())));\n \n   tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();\n   registry_.AddInterface(\n      base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,\n                          base::Unretained(tracing_agent_registry_.get())));\n\n  tracing_coordinator_ = std::make_unique<tracing::Coordinator>();\n  registry_.AddInterface(\n      base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,\n                          base::Unretained(tracing_coordinator_.get())));\n}\n",
        "llama3.1 Summary": "The patch separates the heap profiler's service into its own service with correct capabilities, preventing other instances from using it. This change was made to address a bug that caused incorrect behavior due to shared resources between services.",
        "llama3.1 CWE": "CWE-416",
        "llama3.1 CVE": "CVE-2022-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5757",
            "BERTScore Recall": "0.5451",
            "BERTScore F1": "0.5600"
        },
        "llama3.1 Cosine_Similarity": 0.46278029680252075,
        "Mistral Summary": "The patch changes split the memory-infra coordinator service into two separate instances, one for heap profiler and another for other instances. This allows each service to use the correct capabilities, preventing potential resource mismanagement or conflicts within the system.",
        "Mistral CWE": "CWE-399 (Resource Management Errors)",
        "Mistral CVE": "Not applicable as this is a non-public codebase",
        "Mistral Cosine_Similarity": 0.40828680992126465,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5493",
            "BERTScore Recall": "0.5429",
            "BERTScore F1": "0.5461"
        },
        "Tokens Used": ""
    },
    {
        "num": 2,
        "codeLink": "https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "Don't load .pk3s as .dlls, and don't load user config files from .pk3s.",
        "fixed_function": "void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n\t// Don't load any DLLs that end with the pk3 extension\n\tif (COM_CompareExtension(name, \".pk3\"))\n\t{\n\t\tCom_Printf(\"Rejecting DLL named \\\"%s\\\"\", name);\n\t\treturn NULL;\n\t}\n\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n \t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}\n",
        "vul_function": "void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n \t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}\n",
        "llama3.1 Summary": "The patch changes the function to reject DLL loading for files ending with the \".pk3\" extension and prevents loading of user configuration files from PK3 archives. This change was applied to prevent potential security risks associated with loading malicious code from game data files. Fixed version of function: void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n\t// Don't load any DLLs that end with the pk3 extension\n\tif (COM_CompareExtension(name, \".pk3\"))\n\t{\n\t\tCom_Printf(\"Rejecting DLL named \\\"%s\\\"\", name);\n\t\treturn NULL;\n\t}\n\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n \t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}",
        "llama3.1 CWE": "CWE-426",
        "llama3.1 CVE": "CVE-2020-16996",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3909",
            "BERTScore Recall": "0.4871",
            "BERTScore F1": "0.4337"
        },
        "llama3.1 Cosine_Similarity": 0.5140527486801147,
        "Mistral Summary": "The patch changes the behavior of the function by checking if the loaded DLL ends with the \".pk3\" extension and rejecting it. This prevents path traversal attacks that could load user config files from .pk3 files under certain directory structures.",
        "Mistral CWE": "CWE-22 (Path Traversal)",
        "Mistral CVE": "N/A (The provided code does not contain specific information to generate a CVE ID automatically)",
        "Mistral Cosine_Similarity": 0.41855180263519287,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5797",
            "BERTScore Recall": "0.5221",
            "BERTScore F1": "0.5494"
        },
        "Tokens Used": ""
    },
    {
        "num": 3,
        "codeLink": "https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07",
        "CVE ID": "CVE-2018-6080",
        "CVE Details": "Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .",
        "CWE ID": "CWE-269",
        "commit_message": "memory-infra: split up memory-infra coordinator service into two\n\nThis allows for heap profiler to use its own service with correct\ncapabilities and all other instances to use the existing coordinator\nservice.\n\nBug: 792028\nChange-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd\nReviewed-on: https://chromium-review.googlesource.com/836896\nCommit-Queue: Lalit Maganti <lalitm@chromium.org>\nReviewed-by: Daniel Cheng <dcheng@chromium.org>\nReviewed-by: oysteine <oysteine@chromium.org>\nReviewed-by: Albert J. Wong <ajwong@chromium.org>\nReviewed-by: Hector Dearman <hjd@chromium.org>\nCr-Commit-Position: refs/heads/master@{#529059}",
        "fixed_function": "void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n",
        "vul_function": "void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n    RequestGlobalDumpCallback callback) {\n  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n  coordinator->GetVmRegionsForHeapProfiler(callback);\n}\n",
        "llama3.1 Summary": "The patch changes the function to use a new service instance for heap profiler, which has correct capabilities. This was applied to prevent potential issues with incorrect capability usage in other instances.\n\nFixed version of function: void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n Vulnerable version of function: void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n    RequestGlobalDumpCallback callback) {\n  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n  if (callback.IsHeapProfiling()) {\n      // Use a new service instance for heap profiler.\n      coordinator->SetServiceType(ServiceTypes::kHeapProfiler);\n  }\n  coordinator->GetVmRegions(callback);\n}",
        "llama3.1 CWE": "CWE-918",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3480",
            "BERTScore Recall": "0.5061",
            "BERTScore F1": "0.4124"
        },
        "llama3.1 Cosine_Similarity": 0.45755136013031006,
        "Mistral Summary": "The patch separates the coordinator service for the heap profiler from the existing one. This allows each service to have its own capabilities, preventing potential resource leaks or cleanup issues that might have occurred due to sharing resources between the services.",
        "Mistral CWE": "CWE-369 (Insufficient Resource Release or Cleanup)",
        "Mistral CVE": "CVE-XXXX-XXXX (Not provided, as it's not in the scope of this question)",
        "Mistral Cosine_Similarity": 0.3703005313873291,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5476",
            "BERTScore Recall": "0.5359",
            "BERTScore F1": "0.5417"
        },
        "Tokens Used": ""
    },
    {
        "num": 4,
        "codeLink": "https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07",
        "CVE ID": "CVE-2018-6080",
        "CVE Details": "Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .",
        "CWE ID": "CWE-269",
        "commit_message": "memory-infra: split up memory-infra coordinator service into two\n\nThis allows for heap profiler to use its own service with correct\ncapabilities and all other instances to use the existing coordinator\nservice.\n\nBug: 792028\nChange-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd\nReviewed-on: https://chromium-review.googlesource.com/836896\nCommit-Queue: Lalit Maganti <lalitm@chromium.org>\nReviewed-by: Daniel Cheng <dcheng@chromium.org>\nReviewed-by: oysteine <oysteine@chromium.org>\nReviewed-by: Albert J. Wong <ajwong@chromium.org>\nReviewed-by: Hector Dearman <hjd@chromium.org>\nCr-Commit-Position: refs/heads/master@{#529059}",
        "fixed_function": "void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n  if (!helper_) {\n    context()->connector()->BindInterface(\n        resource_coordinator::mojom::kServiceName, &helper_);\n  }\n\n  helper_->GetVmRegionsForHeapProfiler(base::Bind(\n      &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n      weak_factory_.GetWeakPtr(), keep_small_allocations,\n      strip_path_from_mapped_files, base::Passed(&callback)));\n }\n",
        "vul_function": "void ProfilingService::DumpProcessesForTracing(\n     bool keep_small_allocations,\n     bool strip_path_from_mapped_files,\n     DumpProcessesForTracingCallback callback) {\n  memory_instrumentation::MemoryInstrumentation::GetInstance()\n      ->GetVmRegionsForHeapProfiler(base::Bind(\n          &ProfilingService::OnGetVmRegionsCompleteForDumpProcessesForTracing,\n          weak_factory_.GetWeakPtr(), keep_small_allocations,\n          strip_path_from_mapped_files, base::Passed(&callback)));\n }\n",
        "llama3.1 Summary": "The patch changes the function to use its own service with correct capabilities, avoiding potential security issues caused by using an existing coordinator service. This fix was applied to prevent unexpected behavior and ensure the heap profiler functions correctly in the memory-instrumentation infrastructure.",
        "llama3.1 CWE": "CWE-601",
        "llama3.1 CVE": "CVE-2018-10970",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5738",
            "BERTScore Recall": "0.5517",
            "BERTScore F1": "0.5626"
        },
        "llama3.1 Cosine_Similarity": 0.4717711806297302,
        "Mistral Summary": "The patch changes the method used to retrieve data from the memory instrumentation, moving from using a global instance to using a local service-specific instance. This helps prevent potential Cross-Site Scripting (XSS) attacks by ensuring that different services use their own isolated instances and capabilities.",
        "Mistral CWE": "CWE-319 (Cross-Site Scripting)",
        "Mistral CVE": "CVE-XXXX-XXXX (Assigned based on the specific instance of this vulnerability)",
        "Mistral Cosine_Similarity": 0.5312128067016602,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5630",
            "BERTScore Recall": "0.5481",
            "BERTScore F1": "0.5554"
        },
        "Tokens Used": ""
    },
    {
        "num": 5,
        "codeLink": "https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef",
        "CVE ID": "CVE-2017-5940",
        "CVE Details": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",
        "CWE ID": "CWE-269",
        "commit_message": "security fix",
        "fixed_function": "static void copy_xauthority(void) {\n\tchar *src = RUN_XAUTHORITY_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n\t\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\t\n \tunlink(src);\n }\n",
        "vul_function": "static void copy_xauthority(void) {\n\tchar *src = RUN_XAUTHORITY_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n\tif (chown(dest, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n\t\terrExit(\"chmod\");\n \tunlink(src);\n }\n",
        "llama3.1 Summary": "The patch changes the way the .Xauthority file is copied, removing a potential race condition by using asprintf to construct the destination path and then immediately checking for symbolic links. This was applied to prevent unauthorized access to sensitive files in the user's home directory. Fixed version of function: static void copy_xauthority(void) {\n\tchar *src = RUN_XAUTHORITY_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n\t\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\t\n \tunlink(src);\n }",
        "llama3.1 CWE": "CWE-77",
        "llama3.1 CVE": "CVE-2023-01234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3947",
            "BERTScore Recall": "0.5063",
            "BERTScore F1": "0.4436"
        },
        "llama3.1 Cosine_Similarity": 0.36153489351272583,
        "Mistral Summary": "The patch changes the function to copy .Xauthority file without using fork(), preventing potential privilege escalation by not allowing a child process to execute with root privileges during the copy operation. The previous version allowed a potential attacker to manipulate the destination path, leading to directory traversal or unauthorized access to user directories.",
        "Mistral CWE": "CWE-264 (Privilege Escalation or Root HTML: File Permissions, Path Traversal, or User Directory Access)",
        "Mistral CVE": "Not assigned as it requires a public disclosure and an assessment by the appropriate authority.",
        "Mistral Cosine_Similarity": 0.2881510257720947,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5933",
            "BERTScore Recall": "0.5042",
            "BERTScore F1": "0.5451"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "All: Merge some file writing extension checks",
        "fixed_function": "void Con_Dump_f( void ) {\n\tint l, x, i;\n\tshort   *line;\n\tfileHandle_t f;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: condump <filename>\\n\" );\n\t\treturn;\n\t}\n\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n \n\tif (!COM_CompareExtension(filename, \".txt\"))\n\t{\n\t\tCom_Printf(\"Con_Dump_f: Only the \\\".txt\\\" extension is supported by this command!\\n\");\n\t\treturn;\n\t}\n\n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\tfor ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( x = 0 ; x < con.linewidth ; x++ )\n\t\t\tif ( ( line[x] & 0xff ) != ' ' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( x != con.linewidth ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( i = 0; i < con.linewidth; i++ )\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor ( x = con.linewidth - 1 ; x >= 0 ; x-- )\n\t\t{\n\t\t\tif ( buffer[x] == ' ' ) {\n\t\t\t\tbuffer[x] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write( buffer, strlen( buffer ), f );\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}\n",
        "vul_function": "void Con_Dump_f( void ) {\n\tint l, x, i;\n\tshort   *line;\n\tfileHandle_t f;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: condump <filename>\\n\" );\n\t\treturn;\n\t}\n\n \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n \tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n \n \tf = FS_FOpenFileWrite( filename );\n \tif ( !f ) {\n \t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\n\tfor ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( x = 0 ; x < con.linewidth ; x++ )\n\t\t\tif ( ( line[x] & 0xff ) != ' ' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( x != con.linewidth ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( i = 0; i < con.linewidth; i++ )\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor ( x = con.linewidth - 1 ; x >= 0 ; x-- )\n\t\t{\n\t\t\tif ( buffer[x] == ' ' ) {\n\t\t\t\tbuffer[x] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write( buffer, strlen( buffer ), f );\n\t}\n\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}\n",
        "llama3.1 Summary": "The patch fixes a vulnerability by adding a check to ensure that only the \".txt\" extension is supported, preventing potential buffer overflow attacks. The fix ensures that the filename has the correct extension before attempting to write it to file.",
        "llama3.1 CWE": "CWE-20",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5721",
            "BERTScore Recall": "0.4554",
            "BERTScore F1": "0.5071"
        },
        "llama3.1 Cosine_Similarity": 0.3015751838684082,
        "Mistral Summary": "The patch changes add a check to ensure the filename provided has the correct extension before writing data to it. This was applied to prevent a potential buffer overflow vulnerability due to writing unchecked user-supplied data directly into a buffer without checking its size.",
        "Mistral CWE": "CWE-125 (Buffer Copy Without Checking Size)",
        "Mistral CVE": "Unassigned (The commit message does not provide sufficient information to assign a specific CVE ID)",
        "Mistral Cosine_Similarity": 0.33276915550231934,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5732",
            "BERTScore Recall": "0.4715",
            "BERTScore F1": "0.5174"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19",
        "CVE ID": "CVE-2017-15906",
        "CVE Details": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
        "CWE ID": "CWE-269",
        "commit_message": "disallow creation (of empty files) in read-only mode; reported by\nMichal Zalewski, feedback & ok deraadt@",
        "fixed_function": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) != O_RDONLY ||\n\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n",
        "vul_function": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n",
        "llama3.1 Summary": "The patch changes the condition for refusing open requests in read-only mode to correctly check for write operations. This was applied to prevent potential attacks where an attacker could create empty files on a server, which was reported by Michal Zalewski and reviewed by deraadt@.",
        "llama3.1 CWE": "CWE-22",
        "llama3.1 CVE": "CVE-2004-2611",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.6484",
            "BERTScore Recall": "0.6786",
            "BERTScore F1": "0.6632"
        },
        "llama3.1 Cosine_Similarity": 0.43248069286346436,
        "Mistral Summary": "Fixed version disallows creation of empty files in read-only mode to prevent unintended file modification. The patch ensures that the 'O_CREAT' and 'O_TRUNC' flags are not allowed when the operation is read-only.",
        "Mistral CWE": "CWE-264",
        "Mistral CVE": "CVE-YYYY-ZZZZ-AAA",
        "Mistral Cosine_Similarity": 0.5359554886817932,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5801",
            "BERTScore Recall": "0.5773",
            "BERTScore F1": "0.5787"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/netblue30/firejail/commit/38d418505e9ee2d326557e5639e8da49c298858f",
        "CVE ID": "CVE-2017-5940",
        "CVE Details": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",
        "CWE ID": "CWE-269",
        "commit_message": "security fix",
        "fixed_function": "static int store_asoundrc(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n",
        "vul_function": "static int store_asoundrc(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n",
        "llama3.1 Summary": "The patch fixes a potential symbolic link attack vulnerability by ensuring that the target of a symbolic link does not point to a location outside the user's home directory. The change adds a realpath call to canonicalize the path, and checks if the resulting path starts with the user's home directory before allowing file copy operations.",
        "llama3.1 CWE": "CWE-426",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5635",
            "BERTScore Recall": "0.4897",
            "BERTScore F1": "0.5240"
        },
        "llama3.1 Cosine_Similarity": 0.35420143604278564,
        "Mistral Summary": null,
        "Mistral CWE": "CWE-295 (Path Traversal)\n   CVE ID: Not provided, as it is not possible to generate a specific CVE ID without additional context and verification by a vulnerability coordination body such as Mitre or ISC.\n\n   Fixed version of function: The patch updates the code to ensure that the file being copied (`.asoundrc`) is located within the user's home directory before copying it, preventing potential path traversal attacks. By enforcing this check, unauthorized access to sensitive files or directories can be mitigated.",
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.056159019470214844,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3576",
            "BERTScore Recall": "0.2249",
            "BERTScore F1": "0.2761"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",
        "fixed_function": " void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n\n\t// Don't load any DLLs that end with the pk3 extension\n\tif (COM_CompareExtension(name, \".pk3\"))\n\t{\n\t\tCom_Printf(\"Rejecting DLL named \\\"%s\\\"\", name);\n\t\treturn NULL;\n\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n\t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}\n",
        "vul_function": " void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n\t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}\n",
        "llama3.1 Summary": "The patch changes the function to reject loading DLLs that end with the \".pk3\" extension and prevents loading of user configuration files from PK3 archives, thus preventing arbitrary code execution via malicious .pk3 files. This change was applied to prevent potential security vulnerabilities arising from the loading of arbitrary code from game data packages.\nFixed version of function:  void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n\n\t// Don't load any DLLs that end with the pk3 extension\n\tif (COM_CompareExtension(name, \".pk3\"))\n\t{\n\t\tCom_Printf(\"Rejecting DLL named \\\"%s\\\"\", name);\n\t\treturn NULL;\n\t}\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n\t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}",
        "llama3.1 CWE": "CWE-20",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3933",
            "BERTScore Recall": "0.4897",
            "BERTScore F1": "0.4362"
        },
        "llama3.1 Cosine_Similarity": 0.5157352685928345,
        "Mistral Summary": "The patch changes the function to reject loading .pk3 files as DLLs, preventing arbitrary code execution from user-supplied data. This was applied to prevent potential security vulnerabilities that could arise from executing unintended code.",
        "Mistral CWE": "CWE-22 (Improper Access Control)",
        "Mistral CVE": "No specific CVE ID is provided in the commit message. It would be assigned by a Coordination Center for Vulnerability Disclosure if this code were publicly disclosed.",
        "Mistral Cosine_Similarity": 0.5054264664649963,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.6390",
            "BERTScore Recall": "0.5265",
            "BERTScore F1": "0.5773"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07",
        "CVE ID": "CVE-2018-6080",
        "CVE Details": "Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .",
        "CWE ID": "CWE-269",
        "commit_message": "memory-infra: split up memory-infra coordinator service into two\n\nThis allows for heap profiler to use its own service with correct\ncapabilities and all other instances to use the existing coordinator\nservice.\n\nBug: 792028\nChange-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd\nReviewed-on: https://chromium-review.googlesource.com/836896\nCommit-Queue: Lalit Maganti <lalitm@chromium.org>\nReviewed-by: Daniel Cheng <dcheng@chromium.org>\nReviewed-by: oysteine <oysteine@chromium.org>\nReviewed-by: Albert J. Wong <ajwong@chromium.org>\nReviewed-by: Hector Dearman <hjd@chromium.org>\nCr-Commit-Position: refs/heads/master@{#529059}",
        "fixed_function": " void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n  // This merely strips out the |dump_guid| argument.\n  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                    bool success, uint64_t dump_guid,\n                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n    callback.Run(success, std::move(global_memory_dump));\n  };\n\n  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n      false /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }\n",
        "vul_function": " void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n  RequestGlobalMemoryDump(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {}, callback);\n }\n",
        "llama3.1 Summary": "The patch removes the callback directly in the RequestGlobalMemoryDump function call, instead using a separate adapter lambda to handle the callback. This change was made to allow for heap profiler to use its own service with correct capabilities.\n Fixed version of function:  void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n     const GetVmRegionsForHeapProfilerCallback& callback) {\n  // This merely strips out the |dump_guid| argument.\n  auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                    bool success, uint64_t dump_guid,\n                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n    callback.Run(success, std::move(global_memory_dump));\n  };\n\n  QueuedRequest::Args args(\n       MemoryDumpType::EXPLICITLY_TRIGGERED,\n      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER, {},\n      false /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n }",
        "llama3.1 CWE": "CWE-77",
        "llama3.1 CVE": "CVE-2019-17471",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3278",
            "BERTScore Recall": "0.4870",
            "BERTScore F1": "0.3918"
        },
        "llama3.1 Cosine_Similarity": 0.40223705768585205,
        "Mistral Summary": "The patch changes the approach to requesting memory dumps by splitting up the coordinator service into two. This allows the heap profiler to use its own service with correct capabilities, preventing potential buffer errors that could arise from using a single service for all instances.",
        "Mistral CWE": "CWE-20 (Buffer Error)",
        "Mistral CVE": "CVE-XXXX-XXXX (Assigned by the appropriate authority)",
        "Mistral Cosine_Similarity": 0.4193808436393738,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5486",
            "BERTScore Recall": "0.5289",
            "BERTScore F1": "0.5386"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/b44e68087804e6543a99c87076ab7648d11d9b07",
        "CVE ID": "CVE-2018-6080",
        "CVE Details": "Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .",
        "CWE ID": "CWE-269",
        "commit_message": "memory-infra: split up memory-infra coordinator service into two\n\nThis allows for heap profiler to use its own service with correct\ncapabilities and all other instances to use the existing coordinator\nservice.\n\nBug: 792028\nChange-Id: I84e4ec71f5f1d00991c0516b1424ce7334bcd3cd\nReviewed-on: https://chromium-review.googlesource.com/836896\nCommit-Queue: Lalit Maganti <lalitm@chromium.org>\nReviewed-by: Daniel Cheng <dcheng@chromium.org>\nReviewed-by: oysteine <oysteine@chromium.org>\nReviewed-by: Albert J. Wong <ajwong@chromium.org>\nReviewed-by: Hector Dearman <hjd@chromium.org>\nCr-Commit-Position: refs/heads/master@{#529059}",
        "fixed_function": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n  // Don't allow arbitary processes to obtain VM regions. Only the heap profiler\n  // is allowed to obtain them using the special method on its own dedicated\n  // interface (HeapProfilingHelper).\n  if (level_of_detail ==\n      MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {\n    bindings_.ReportBadMessage(\n        \"Requested global memory dump using level of detail reserved for the \"\n        \"heap profiler.\");\n    return;\n  }\n\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n",
        "vul_function": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n",
        "llama3.1 Summary": "The patch adds a security check to prevent arbitrary processes from obtaining VM regions, ensuring that only the heap profiler is allowed to do so. This change was applied as part of refactoring the memory-infra coordinator service into two separate services with different capabilities, improving overall system security and functionality. Fixed version of function:  void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(     MemoryDumpType dump_type,     MemoryDumpLevelOfDetail level_of_detail,     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {   // Don't allow arbitary processes to obtain VM regions. Only the heap profiler   // is allowed to obtain them using the special method on its own dedicated   // interface (HeapProfilingHelper).   if (level_of_detail ==     MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {     bindings_.ReportBadMessage(         \"Requested global memory dump using level of detail reserved for the \"         \"heap profiler.\");     return;   }    auto adapter =       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,         bool success, uint64_t dump_guid,         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };   QueuedRequest::Args args(dump_type, level_of_detail, {},                           true /* add_to_trace */, base::kNullProcessId);   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback)); }",
        "llama3.1 CWE": "CWE-284",
        "llama3.1 CVE": "CVE-2018-1000802",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3341",
            "BERTScore Recall": "0.5207",
            "BERTScore F1": "0.4070"
        },
        "llama3.1 Cosine_Similarity": 0.5246720314025879,
        "Mistral Summary": "The patch changes the memory-infra coordinator service to split it into two, allowing the heap profiler to use its own service with correct capabilities. This prevents unauthorized instances from accessing VM regions reserved for the heap profiler by removing hardcoded privileges in the original code.",
        "Mistral CWE": "CWE-863 (Hardcoded Credentials)",
        "Mistral CVE": "CVE-XXXX-XXXX (Assuming a newly assigned number for this vulnerability)",
        "Mistral Cosine_Similarity": 0.4638702869415283,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5627",
            "BERTScore Recall": "0.5725",
            "BERTScore F1": "0.5675"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/ioquake/ioq3/commit/f61fe5f6a0419ef4a88d46a128052f2e8352e85d",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "Don't open .pk3 files as OpenAL drivers.",
        "fixed_function": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n \ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n \n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n \n \ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n \n\tif ( COM_CompareExtension( s_alDriver->string, \".pk3\" ) )\n\t{\n\t\tCom_Printf( \"Rejecting DLL named \\\"%s\\\"\", s_alDriver->string );\n\t\treturn qfalse;\n\t}\n\n \tif( !QAL_Init( s_alDriver->string ) )\n \t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}\n",
        "vul_function": "qboolean S_AL_Init( soundInterface_t *si )\n{\n#ifdef USE_OPENAL\n\tconst char* device = NULL;\n\tconst char* inputdevice = NULL;\n\tint i;\n\n\tif( !si ) {\n\t\treturn qfalse;\n\t}\n\n\tfor (i = 0; i < MAX_RAW_STREAMS; i++) {\n\t\tstreamSourceHandles[i] = -1;\n\t\tstreamPlaying[i] = qfalse;\n\t\tstreamSources[i] = 0;\n\t\tstreamNumBuffers[i] = 0;\n\t\tstreamBufIndex[i] = 0;\n\t}\n\n\ts_alPrecache = Cvar_Get( \"s_alPrecache\", \"1\", CVAR_ARCHIVE );\n\ts_alGain = Cvar_Get( \"s_alGain\", \"1.0\", CVAR_ARCHIVE );\n\ts_alSources = Cvar_Get( \"s_alSources\", \"96\", CVAR_ARCHIVE );\n\ts_alDopplerFactor = Cvar_Get( \"s_alDopplerFactor\", \"1.0\", CVAR_ARCHIVE );\n\ts_alDopplerSpeed = Cvar_Get( \"s_alDopplerSpeed\", \"9000\", CVAR_ARCHIVE );\n\ts_alMinDistance = Cvar_Get( \"s_alMinDistance\", \"120\", CVAR_CHEAT );\n\ts_alMaxDistance = Cvar_Get(\"s_alMaxDistance\", \"1024\", CVAR_CHEAT);\n \ts_alRolloff = Cvar_Get( \"s_alRolloff\", \"2\", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\"s_alGraceDistance\", \"512\", CVAR_CHEAT);\n \n\ts_alDriver = Cvar_Get( \"s_alDriver\", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n \n \ts_alInputDevice = Cvar_Get( \"s_alInputDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\"s_alDevice\", \"\", CVAR_ARCHIVE | CVAR_LATCH);\n \n \tif( !QAL_Init( s_alDriver->string ) )\n \t{\n\t\tCom_Printf( \"Failed to load library: \\\"%s\\\".\\n\", s_alDriver->string );\n\t\tif( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tdevice = s_alDevice->string;\n\tif(device && !*device)\n\t\tdevice = NULL;\n\n\tinputdevice = s_alInputDevice->string;\n\tif(inputdevice && !*inputdevice)\n\t\tinputdevice = NULL;\n\n\n\tenumeration_all_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATE_ALL_EXT\");\n\tenumeration_ext = qalcIsExtensionPresent(NULL, \"ALC_ENUMERATION_EXT\");\n\n\tif(enumeration_ext || enumeration_all_ext)\n\t{\n\t\tchar devicenames[16384] = \"\";\n\t\tconst char *devicelist;\n#ifdef _WIN32\n\t\tconst char *defaultdevice;\n#endif\n\t\tint curlen;\n\n\t\tif(enumeration_all_ext)\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);\n#ifdef _WIN32\n\t\t\tdefaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);\n#endif\n\t\t\tenumeration_ext = qtrue;\n\t\t}\n\n#ifdef _WIN32\n\t\tif(!device && defaultdevice && !strcmp(defaultdevice, \"Generic Hardware\"))\n\t\t\tdevice = \"Generic Software\";\n#endif\n\n\n\t\tif(devicelist)\n\t\t{\n\t\t\twhile((curlen = strlen(devicelist)))\n\t\t\t{\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), devicelist);\n\t\t\t\tQ_strcat(devicenames, sizeof(devicenames), \"\\n\");\n\n\t\t\t\tdevicelist += curlen + 1;\n\t\t\t}\n\t\t}\n\n\t\ts_alAvailableDevices = Cvar_Get(\"s_alAvailableDevices\", devicenames, CVAR_ROM | CVAR_NORESTART);\n\t}\n\n\talDevice = qalcOpenDevice(device);\n\tif( !alDevice && device )\n\t{\n\t\tCom_Printf( \"Failed to open OpenAL device '%s', trying default.\\n\", device );\n\t\talDevice = qalcOpenDevice(NULL);\n\t}\n\n\tif( !alDevice )\n\t{\n\t\tQAL_Shutdown( );\n\t\tCom_Printf( \"Failed to open OpenAL device.\\n\" );\n\t\treturn qfalse;\n\t}\n\n\talContext = qalcCreateContext( alDevice, NULL );\n\tif( !alContext )\n\t{\n\t\tQAL_Shutdown( );\n\t\tqalcCloseDevice( alDevice );\n\t\tCom_Printf( \"Failed to create OpenAL context.\\n\" );\n\t\treturn qfalse;\n\t}\n\tqalcMakeContextCurrent( alContext );\n\n\tS_AL_BufferInit( );\n\tS_AL_SrcInit( );\n\n\tqalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);\n\tqalDopplerFactor( s_alDopplerFactor->value );\n\tqalSpeedOfSound( s_alDopplerSpeed->value );\n\n#ifdef USE_VOIP\n\ts_alCapture = Cvar_Get( \"s_alCapture\", \"1\", CVAR_ARCHIVE | CVAR_LATCH );\n\tif (!s_alCapture->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\\n\");\n\t}\n#if USE_MUMBLE\n\telse if (cl_useMumble->integer)\n\t{\n\t\tCom_Printf(\"OpenAL capture support disabled for Mumble support\\n\");\n\t}\n#endif\n\telse\n\t{\n#ifdef __APPLE__\n\t\tif (qalcCaptureOpenDevice == NULL)\n#else\n\t\tif (!qalcIsExtensionPresent(NULL, \"ALC_EXT_capture\"))\n#endif\n\t\t{\n\t\t\tCom_Printf(\"No ALC_EXT_capture support, can't record audio.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar inputdevicenames[16384] = \"\";\n\t\t\tconst char *inputdevicelist;\n\t\t\tconst char *defaultinputdevice;\n\t\t\tint curlen;\n\n\t\t\tcapture_ext = qtrue;\n\n\t\t\tinputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);\n\t\t\tdefaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);\n\n\t\t\tif (inputdevicelist)\n\t\t\t{\n\t\t\t\twhile((curlen = strlen(inputdevicelist)))\n\t\t\t\t{\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);\n\t\t\t\t\tQ_strcat(inputdevicenames, sizeof(inputdevicenames), \"\\n\");\n\t\t\t\t\tinputdevicelist += curlen + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts_alAvailableInputDevices = Cvar_Get(\"s_alAvailableInputDevices\", inputdevicenames, CVAR_ROM | CVAR_NORESTART);\n\n\t\t\tCom_Printf(\"OpenAL default capture device is '%s'\\n\", defaultinputdevice ? defaultinputdevice : \"none\");\n\t\t\talCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\tif( !alCaptureDevice && inputdevice )\n\t\t\t{\n\t\t\t\tCom_Printf( \"Failed to open OpenAL Input device '%s', trying default.\\n\", inputdevice );\n\t\t\t\talCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);\n\t\t\t}\n\t\t\tCom_Printf( \"OpenAL capture device %s.\\n\",\n\t\t\t\t    (alCaptureDevice == NULL) ? \"failed to open\" : \"opened\");\n\t\t}\n\t}\n#endif\n\n\tsi->Shutdown = S_AL_Shutdown;\n\tsi->StartSound = S_AL_StartSound;\n\tsi->StartLocalSound = S_AL_StartLocalSound;\n\tsi->StartBackgroundTrack = S_AL_StartBackgroundTrack;\n\tsi->StopBackgroundTrack = S_AL_StopBackgroundTrack;\n\tsi->RawSamples = S_AL_RawSamples;\n\tsi->StopAllSounds = S_AL_StopAllSounds;\n\tsi->ClearLoopingSounds = S_AL_ClearLoopingSounds;\n\tsi->AddLoopingSound = S_AL_AddLoopingSound;\n\tsi->AddRealLoopingSound = S_AL_AddRealLoopingSound;\n\tsi->StopLoopingSound = S_AL_StopLoopingSound;\n\tsi->Respatialize = S_AL_Respatialize;\n\tsi->UpdateEntityPosition = S_AL_UpdateEntityPosition;\n\tsi->Update = S_AL_Update;\n\tsi->DisableSounds = S_AL_DisableSounds;\n\tsi->BeginRegistration = S_AL_BeginRegistration;\n\tsi->RegisterSound = S_AL_RegisterSound;\n\tsi->ClearSoundBuffer = S_AL_ClearSoundBuffer;\n\tsi->SoundInfo = S_AL_SoundInfo;\n\tsi->SoundList = S_AL_SoundList;\n\n#ifdef USE_VOIP\n\tsi->StartCapture = S_AL_StartCapture;\n\tsi->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;\n\tsi->Capture = S_AL_Capture;\n\tsi->StopCapture = S_AL_StopCapture;\n\tsi->MasterGain = S_AL_MasterGain;\n#endif\n\n\treturn qtrue;\n#else\n\treturn qfalse;\n#endif\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3001",
            "BERTScore Recall": "0.2141",
            "BERTScore F1": "0.2499"
        },
        "llama3.1 Cosine_Similarity": 0.007130444049835205,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.007130444049835205,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3001",
            "BERTScore Recall": "0.2141",
            "BERTScore F1": "0.2499"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/iortcw/iortcw/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "All: Don't load .pk3s as .dlls, and don't load user config files from .pk3s",
        "fixed_function": "void CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init();\n\n\tif(!com_fullyInitialized)\n\t{\n\t\tCL_ClearState();\n\t\tclc.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t\tcl_oldGameSet = qfalse;\n\t}\n\n\tcls.realtime = 0;\n\n\tCL_InitInput();\n\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\n\tcl_motd = Cvar_Get( \"cl_motd\", \"1\", 0 );\n#endif\n\tcl_autoupdate = Cvar_Get( \"cl_autoupdate\", \"0\", CVAR_ARCHIVE );\n\n\tcl_timeout = Cvar_Get( \"cl_timeout\", \"200\", 0 );\n\n\tcl_wavefilerecord = Cvar_Get( \"cl_wavefilerecord\", \"0\", CVAR_TEMP );\n\n\tcl_timeNudge = Cvar_Get( \"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get( \"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_shownuments = Cvar_Get( \"cl_shownuments\", \"0\", CVAR_TEMP );\n\tcl_visibleClients = Cvar_Get( \"cl_visibleClients\", \"0\", CVAR_TEMP );\n\tcl_showServerCommands = Cvar_Get( \"cl_showServerCommands\", \"0\", 0 );\n\tcl_showSend = Cvar_Get( \"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get( \"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get( \"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get( \"rconPassword\", \"\", CVAR_TEMP );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get( \"timedemo\", \"0\", 0 );\n\tcl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\n\tcl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_avidemo = Cvar_Get( \"cl_avidemo\", \"0\", 0 );\n\tcl_forceavidemo = Cvar_Get( \"cl_forceavidemo\", \"0\", 0 );\n\n\trconAddress = Cvar_Get( \"rconAddress\", \"\", 0 );\n\n\tcl_yawspeed = Cvar_Get( \"cl_yawspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_pitchspeed = Cvar_Get( \"cl_pitchspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_anglespeedkey = Cvar_Get( \"cl_anglespeedkey\", \"1.5\", 0 );\n\n\tcl_maxpackets = Cvar_Get( \"cl_maxpackets\", \"38\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get( \"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_showPing = Cvar_Get( \"cl_showPing\", \"0\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get( \"cl_run\", \"1\", CVAR_ARCHIVE );\n\tcl_sensitivity = Cvar_Get( \"sensitivity\", \"5\", CVAR_ARCHIVE );\n\tcl_mouseAccel = Cvar_Get( \"cl_mouseAccel\", \"0\", CVAR_ARCHIVE );\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n \n \tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"1\", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n #endif\n \n\tCvar_Get( \"cg_autoswitch\", \"0\", CVAR_ARCHIVE );\n\n\tCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\n\n\tcl_conXOffset = Cvar_Get( \"cl_conXOffset\", \"0\", 0 );\n\tcl_inGameVideo = Cvar_Get( \"r_inGameVideo\", \"1\", CVAR_ARCHIVE );\n\n\tcl_serverStatusResendTime = Cvar_Get( \"cl_serverStatusResendTime\", \"750\", 0 );\n\n\tcl_recoilPitch = Cvar_Get( \"cg_recoilPitch\", \"0\", CVAR_ROM );\n\n\tcl_bypassMouseInput = Cvar_Get( \"cl_bypassMouseInput\", \"0\", 0 ); //CVAR_ROM );\t\t\t// NERVE - SMF\n\n\tm_pitch = Cvar_Get( \"m_pitch\", \"0.022\", CVAR_ARCHIVE );\n\tm_yaw = Cvar_Get( \"m_yaw\", \"0.022\", CVAR_ARCHIVE );\n\tm_forward = Cvar_Get( \"m_forward\", \"0.25\", CVAR_ARCHIVE );\n\tm_side = Cvar_Get( \"m_side\", \"0.25\", CVAR_ARCHIVE );\n\tm_filter = Cvar_Get( \"m_filter\", \"0\", CVAR_ARCHIVE );\n\n\tj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\n\tj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\n\tj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\n\tj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\n\tj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\n\n\tj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\n\tj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\n\tj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\n\tj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\n\tj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\n\n\tCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\tcl_guid = Cvar_Get( \"cl_guid\", \"unknown\", CVAR_USERINFO | CVAR_ROM );\n\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\n\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\n\n\tCvar_Get( \"cg_drawCompass\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawNotifyText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_quickMessageAlt\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_popupLimboMenu\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_descriptiveText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawTeamOverlay\", \"2\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_uselessNostalgia\", \"0\", CVAR_ARCHIVE ); // JPW NERVE\n\tCvar_Get( \"cg_drawGun\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_cursorHints\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_voiceSpriteTime\", \"6000\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_teamChatsOnly\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceChats\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceText\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_crosshairSize\", \"48\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawCrosshair\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomDefaultSniper\", \"20\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomstepsniper\", \"2\", CVAR_ARCHIVE );\n\n\tCvar_Get( \"mp_playerType\", \"0\", 0 );\n\tCvar_Get( \"mp_currentPlayerType\", \"0\", 0 );\n\tCvar_Get( \"mp_weapon\", \"0\", 0 );\n\tCvar_Get( \"mp_team\", \"0\", 0 );\n\tCvar_Get( \"mp_currentTeam\", \"0\", 0 );\n\n\tCvar_Get( \"name\", \"WolfPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tcl_rate = Cvar_Get( \"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000\n\tCvar_Get( \"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"model\", \"multi\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"head\", \"default\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"color\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get( \"password\", \"\", CVAR_USERINFO );\n\tCvar_Get( \"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n#ifdef USE_MUMBLE\n\tcl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\n\tcl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n\n#ifdef USE_VOIP\n\tcl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\n\tcl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\n\tcl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\n\tcl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\n\tcl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\n\tcl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\n\tcl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\n\n\tcl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\n\tCvar_CheckRange( cl_voip, 0, 1, qtrue );\n\tcl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\n\n\tCvar_Get( \"cg_autoactivate\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get( \"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\tCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\n\n\tCvar_Get( \"cg_autoReload\", \"1\", CVAR_ARCHIVE | CVAR_USERINFO );\n\n\tcl_missionStats = Cvar_Get( \"g_missionStats\", \"0\", CVAR_ROM );\n\tcl_waitForFire = Cvar_Get( \"cl_waitForFire\", \"0\", CVAR_ROM );\n\n\tcl_language = Cvar_Get( \"cl_language\", \"0\", CVAR_ARCHIVE );\n\tcl_debugTranslation = Cvar_Get( \"cl_debugTranslation\", \"0\", 0 );\n\n\tcl_updateavailable = Cvar_Get( \"cl_updateavailable\", \"0\", CVAR_ROM );\n\tcl_updatefiles = Cvar_Get( \"cl_updatefiles\", \"\", CVAR_ROM );\n\n\tQ_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );\n\n\tCmd_AddCommand( \"cmd\", CL_ForwardToServer_f );\n\tCmd_AddCommand( \"configstrings\", CL_Configstrings_f );\n\tCmd_AddCommand( \"clientinfo\", CL_Clientinfo_f );\n\tCmd_AddCommand( \"snd_restart\", CL_Snd_Restart_f );\n\tCmd_AddCommand( \"vid_restart\", CL_Vid_Restart_f );\n\tCmd_AddCommand( \"ui_restart\", CL_UI_Restart_f );          // NERVE - SMF\n\tCmd_AddCommand( \"disconnect\", CL_Disconnect_f );\n\tCmd_AddCommand( \"record\", CL_Record_f );\n\tCmd_AddCommand( \"demo\", CL_PlayDemo_f );\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand( \"cinematic\", CL_PlayCinematic_f );\n\tCmd_AddCommand( \"stoprecord\", CL_StopRecord_f );\n\tCmd_AddCommand( \"connect\", CL_Connect_f );\n\tCmd_AddCommand( \"reconnect\", CL_Reconnect_f );\n\tCmd_AddCommand( \"localservers\", CL_LocalServers_f );\n\tCmd_AddCommand( \"globalservers\", CL_GlobalServers_f );\n\tCmd_AddCommand( \"rcon\", CL_Rcon_f );\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand( \"ping\", CL_Ping_f );\n\tCmd_AddCommand( \"serverstatus\", CL_ServerStatus_f );\n\tCmd_AddCommand( \"showip\", CL_ShowIP_f );\n\tCmd_AddCommand( \"fs_openedList\", CL_OpenedPK3List_f );\n\tCmd_AddCommand( \"fs_referencedList\", CL_ReferencedPK3List_f );\n\tCmd_AddCommand (\"video\", CL_Video_f );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\n\n\tCmd_AddCommand( \"cache_startgather\", CL_Cache_StartGather_f );\n\tCmd_AddCommand( \"cache_usedfile\", CL_Cache_UsedFile_f );\n\tCmd_AddCommand( \"cache_setindex\", CL_Cache_SetIndex_f );\n\tCmd_AddCommand( \"cache_mapchange\", CL_Cache_MapChange_f );\n\tCmd_AddCommand( \"cache_endgather\", CL_Cache_EndGather_f );\n\n\tCmd_AddCommand( \"updatehunkusage\", CL_UpdateLevelHunkUsage );\n\tCmd_AddCommand( \"updatescreen\", SCR_UpdateScreen );\n\tCmd_AddCommand( \"SaveTranslations\", CL_SaveTranslations_f );     // NERVE - SMF - localization\n\tCmd_AddCommand( \"SaveNewTranslations\", CL_SaveNewTranslations_f );   // NERVE - SMF - localization\n\tCmd_AddCommand( \"LoadTranslations\", CL_LoadTranslations_f );     // NERVE - SMF - localization\n\n\tCmd_AddCommand( \"startSingleplayer\", CL_startSingleplayer_f );      // NERVE - SMF\n\n\tCmd_AddCommand( \"setRecommended\", CL_SetRecommended_f );\n\n\tCL_InitRef();\n\n\tSCR_Init();\n\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tautoupdateChecked = qfalse;\n\tautoupdateStarted = qfalse;\n\n\tCL_InitTranslation();   // NERVE - SMF - localization\n\n\tCL_GenerateQKey();\n\tCL_UpdateGUID( NULL, 0 );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n",
        "vul_function": "void CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init();\n\n\tif(!com_fullyInitialized)\n\t{\n\t\tCL_ClearState();\n\t\tclc.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t\tcl_oldGameSet = qfalse;\n\t}\n\n\tcls.realtime = 0;\n\n\tCL_InitInput();\n\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\n\tcl_motd = Cvar_Get( \"cl_motd\", \"1\", 0 );\n#endif\n\tcl_autoupdate = Cvar_Get( \"cl_autoupdate\", \"0\", CVAR_ARCHIVE );\n\n\tcl_timeout = Cvar_Get( \"cl_timeout\", \"200\", 0 );\n\n\tcl_wavefilerecord = Cvar_Get( \"cl_wavefilerecord\", \"0\", CVAR_TEMP );\n\n\tcl_timeNudge = Cvar_Get( \"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get( \"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_shownuments = Cvar_Get( \"cl_shownuments\", \"0\", CVAR_TEMP );\n\tcl_visibleClients = Cvar_Get( \"cl_visibleClients\", \"0\", CVAR_TEMP );\n\tcl_showServerCommands = Cvar_Get( \"cl_showServerCommands\", \"0\", 0 );\n\tcl_showSend = Cvar_Get( \"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get( \"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get( \"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get( \"rconPassword\", \"\", CVAR_TEMP );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get( \"timedemo\", \"0\", 0 );\n\tcl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\n\tcl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_avidemo = Cvar_Get( \"cl_avidemo\", \"0\", 0 );\n\tcl_forceavidemo = Cvar_Get( \"cl_forceavidemo\", \"0\", 0 );\n\n\trconAddress = Cvar_Get( \"rconAddress\", \"\", 0 );\n\n\tcl_yawspeed = Cvar_Get( \"cl_yawspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_pitchspeed = Cvar_Get( \"cl_pitchspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_anglespeedkey = Cvar_Get( \"cl_anglespeedkey\", \"1.5\", 0 );\n\n\tcl_maxpackets = Cvar_Get( \"cl_maxpackets\", \"38\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get( \"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_showPing = Cvar_Get( \"cl_showPing\", \"0\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get( \"cl_run\", \"1\", CVAR_ARCHIVE );\n\tcl_sensitivity = Cvar_Get( \"sensitivity\", \"5\", CVAR_ARCHIVE );\n\tcl_mouseAccel = Cvar_Get( \"cl_mouseAccel\", \"0\", CVAR_ARCHIVE );\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n \n \tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"1\", CVAR_ARCHIVE );\n #ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n #endif\n \n\tCvar_Get( \"cg_autoswitch\", \"0\", CVAR_ARCHIVE );\n\n\tCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\n\n\tcl_conXOffset = Cvar_Get( \"cl_conXOffset\", \"0\", 0 );\n\tcl_inGameVideo = Cvar_Get( \"r_inGameVideo\", \"1\", CVAR_ARCHIVE );\n\n\tcl_serverStatusResendTime = Cvar_Get( \"cl_serverStatusResendTime\", \"750\", 0 );\n\n\tcl_recoilPitch = Cvar_Get( \"cg_recoilPitch\", \"0\", CVAR_ROM );\n\n\tcl_bypassMouseInput = Cvar_Get( \"cl_bypassMouseInput\", \"0\", 0 ); //CVAR_ROM );\t\t\t// NERVE - SMF\n\n\tm_pitch = Cvar_Get( \"m_pitch\", \"0.022\", CVAR_ARCHIVE );\n\tm_yaw = Cvar_Get( \"m_yaw\", \"0.022\", CVAR_ARCHIVE );\n\tm_forward = Cvar_Get( \"m_forward\", \"0.25\", CVAR_ARCHIVE );\n\tm_side = Cvar_Get( \"m_side\", \"0.25\", CVAR_ARCHIVE );\n\tm_filter = Cvar_Get( \"m_filter\", \"0\", CVAR_ARCHIVE );\n\n\tj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\n\tj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\n\tj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\n\tj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\n\tj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\n\n\tj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\n\tj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\n\tj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\n\tj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\n\tj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\n\n\tCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\tcl_guid = Cvar_Get( \"cl_guid\", \"unknown\", CVAR_USERINFO | CVAR_ROM );\n\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\n\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\n\n\tCvar_Get( \"cg_drawCompass\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawNotifyText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_quickMessageAlt\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_popupLimboMenu\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_descriptiveText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawTeamOverlay\", \"2\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_uselessNostalgia\", \"0\", CVAR_ARCHIVE ); // JPW NERVE\n\tCvar_Get( \"cg_drawGun\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_cursorHints\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_voiceSpriteTime\", \"6000\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_teamChatsOnly\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceChats\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceText\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_crosshairSize\", \"48\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawCrosshair\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomDefaultSniper\", \"20\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomstepsniper\", \"2\", CVAR_ARCHIVE );\n\n\tCvar_Get( \"mp_playerType\", \"0\", 0 );\n\tCvar_Get( \"mp_currentPlayerType\", \"0\", 0 );\n\tCvar_Get( \"mp_weapon\", \"0\", 0 );\n\tCvar_Get( \"mp_team\", \"0\", 0 );\n\tCvar_Get( \"mp_currentTeam\", \"0\", 0 );\n\n\tCvar_Get( \"name\", \"WolfPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tcl_rate = Cvar_Get( \"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000\n\tCvar_Get( \"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"model\", \"multi\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"head\", \"default\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"color\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get( \"password\", \"\", CVAR_USERINFO );\n\tCvar_Get( \"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n#ifdef USE_MUMBLE\n\tcl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\n\tcl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n\n#ifdef USE_VOIP\n\tcl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\n\tcl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\n\tcl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\n\tcl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\n\tcl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\n\tcl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\n\tcl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\n\n\tcl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\n\tCvar_CheckRange( cl_voip, 0, 1, qtrue );\n\tcl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\n\n\tCvar_Get( \"cg_autoactivate\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get( \"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\tCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\n\n\tCvar_Get( \"cg_autoReload\", \"1\", CVAR_ARCHIVE | CVAR_USERINFO );\n\n\tcl_missionStats = Cvar_Get( \"g_missionStats\", \"0\", CVAR_ROM );\n\tcl_waitForFire = Cvar_Get( \"cl_waitForFire\", \"0\", CVAR_ROM );\n\n\tcl_language = Cvar_Get( \"cl_language\", \"0\", CVAR_ARCHIVE );\n\tcl_debugTranslation = Cvar_Get( \"cl_debugTranslation\", \"0\", 0 );\n\n\tcl_updateavailable = Cvar_Get( \"cl_updateavailable\", \"0\", CVAR_ROM );\n\tcl_updatefiles = Cvar_Get( \"cl_updatefiles\", \"\", CVAR_ROM );\n\n\tQ_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );\n\n\tCmd_AddCommand( \"cmd\", CL_ForwardToServer_f );\n\tCmd_AddCommand( \"configstrings\", CL_Configstrings_f );\n\tCmd_AddCommand( \"clientinfo\", CL_Clientinfo_f );\n\tCmd_AddCommand( \"snd_restart\", CL_Snd_Restart_f );\n\tCmd_AddCommand( \"vid_restart\", CL_Vid_Restart_f );\n\tCmd_AddCommand( \"ui_restart\", CL_UI_Restart_f );          // NERVE - SMF\n\tCmd_AddCommand( \"disconnect\", CL_Disconnect_f );\n\tCmd_AddCommand( \"record\", CL_Record_f );\n\tCmd_AddCommand( \"demo\", CL_PlayDemo_f );\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand( \"cinematic\", CL_PlayCinematic_f );\n\tCmd_AddCommand( \"stoprecord\", CL_StopRecord_f );\n\tCmd_AddCommand( \"connect\", CL_Connect_f );\n\tCmd_AddCommand( \"reconnect\", CL_Reconnect_f );\n\tCmd_AddCommand( \"localservers\", CL_LocalServers_f );\n\tCmd_AddCommand( \"globalservers\", CL_GlobalServers_f );\n\tCmd_AddCommand( \"rcon\", CL_Rcon_f );\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand( \"ping\", CL_Ping_f );\n\tCmd_AddCommand( \"serverstatus\", CL_ServerStatus_f );\n\tCmd_AddCommand( \"showip\", CL_ShowIP_f );\n\tCmd_AddCommand( \"fs_openedList\", CL_OpenedPK3List_f );\n\tCmd_AddCommand( \"fs_referencedList\", CL_ReferencedPK3List_f );\n\tCmd_AddCommand (\"video\", CL_Video_f );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\n\n\tCmd_AddCommand( \"cache_startgather\", CL_Cache_StartGather_f );\n\tCmd_AddCommand( \"cache_usedfile\", CL_Cache_UsedFile_f );\n\tCmd_AddCommand( \"cache_setindex\", CL_Cache_SetIndex_f );\n\tCmd_AddCommand( \"cache_mapchange\", CL_Cache_MapChange_f );\n\tCmd_AddCommand( \"cache_endgather\", CL_Cache_EndGather_f );\n\n\tCmd_AddCommand( \"updatehunkusage\", CL_UpdateLevelHunkUsage );\n\tCmd_AddCommand( \"updatescreen\", SCR_UpdateScreen );\n\tCmd_AddCommand( \"SaveTranslations\", CL_SaveTranslations_f );     // NERVE - SMF - localization\n\tCmd_AddCommand( \"SaveNewTranslations\", CL_SaveNewTranslations_f );   // NERVE - SMF - localization\n\tCmd_AddCommand( \"LoadTranslations\", CL_LoadTranslations_f );     // NERVE - SMF - localization\n\n\tCmd_AddCommand( \"startSingleplayer\", CL_startSingleplayer_f );      // NERVE - SMF\n\n\tCmd_AddCommand( \"setRecommended\", CL_SetRecommended_f );\n\n\tCL_InitRef();\n\n\tSCR_Init();\n\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tautoupdateChecked = qfalse;\n\tautoupdateStarted = qfalse;\n\n\tCL_InitTranslation();   // NERVE - SMF - localization\n\n\tCL_GenerateQKey();\n\tCL_UpdateGUID( NULL, 0 );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3001",
            "BERTScore Recall": "0.2141",
            "BERTScore F1": "0.2499"
        },
        "llama3.1 Cosine_Similarity": 0.007130444049835205,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.007130444049835205,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3001",
            "BERTScore Recall": "0.2141",
            "BERTScore F1": "0.2499"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863",
        "CVE ID": "CVE-2017-5940",
        "CVE Details": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",
        "CWE ID": "CWE-269",
        "commit_message": "replace copy_file with copy_file_as_user",
        "fixed_function": "static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n \n \tunlink(src);\n}\n",
        "vul_function": "static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n \n \tunlink(src);\n}\n",
        "llama3.1 Summary": "The patch replaces the vulnerable code that used a forked child process to write the file, which could potentially lead to security issues due to dropped privileges in the child process. By using `copy_file_as_user` directly, the patch ensures the file is written with correct permissions and avoids potential security risks associated with the original implementation. Fixed version of function: static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\tfs_logger2(\"clone\", dest);\n \n \tunlink(src);\n}",
        "llama3.1 CWE": "CWE-88",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4045",
            "BERTScore Recall": "0.5089",
            "BERTScore F1": "0.4507"
        },
        "llama3.1 Cosine_Similarity": 0.2600831985473633,
        "Mistral Summary": "The patch changes the method used to copy the file from using a forked process with `copy_file` function, which may potentially allow path traversal, to directly using the `copy_file_as_user` function, ensuring that only the user-specific home directory is accessed.",
        "Mistral CWE": "CWE-294 (Path Traversal)",
        "Mistral CVE": "Not provided (As it depends on the specific software version and other factors)",
        "Mistral Cosine_Similarity": 0.4116465449333191,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5356",
            "BERTScore Recall": "0.4908",
            "BERTScore F1": "0.5122"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863",
        "CVE ID": "CVE-2017-5940",
        "CVE Details": "Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180.",
        "CWE ID": "CWE-269",
        "commit_message": "replace copy_file with copy_file_as_user",
        "fixed_function": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n \t\t\treturn 0;\n \t\t}\n \n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n\treturn 0;\n}\n",
        "vul_function": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n \t\t\treturn 0;\n \t\t}\n \n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tdrop_privs(0);\n\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n\t\t\tif (rv)\n\t\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t\telse {\n\t\t\t\tfs_logger2(\"clone\", dest);\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n \t\treturn 1; // file copied\n \t}\n \t\n\treturn 0;\n}\n",
        "llama3.1 Summary": "The patch replaces the use of a forked child process to transfer files in a private home directory with a call to the `copy_file_as_user` function, which ensures that file ownership and permissions are correctly set for the target file. This change is necessary because the original code did not properly handle file transfer in private directories, potentially leading to security vulnerabilities such as unauthorized access or modification of sensitive data. Fixed version of function: static int store_xauthority(void) { fs_build_mnt_dir(); char *src; char *dest = RUN_XAUTHORITY_FILE; FILE *fp = fopen(dest, \"w\"); if (fp) { fprintf(fp, \"\\n\"); SET_PERMS_STREAM(fp, getuid(), getgid(), 0600); fclose(fp); } if (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1) errExit(\"asprintf\"); struct stat s; if (stat(src, &s) == 0) { if (is_link(src)) { fprintf(stderr, \"Warning: invalid .Xauthority file\\n\"); return 0; } copy_file_as_user(src, dest, getuid(), getgid(), 0600); fs_logger2(\"clone\", dest); return 1; // file copied } return 0; }",
        "llama3.1 CWE": "CWE-426",
        "llama3.1 CVE": "CVE-2022-23456",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4265",
            "BERTScore Recall": "0.5369",
            "BERTScore F1": "0.4754"
        },
        "llama3.1 Cosine_Similarity": 0.3894346356391907,
        "Mistral Summary": "The patch changes the function to use `copy_file_as_user` instead of `copy_file`, ensuring that the file is copied with the correct permissions by running the copy operation as the user who owns the destination file, thus reducing the potential for privilege escalation.",
        "Mistral CWE": "CWE-267 (Privilege Gives Elevation)",
        "Mistral CVE": "Not provided as it is dependent on the specific software, version, and environment.",
        "Mistral Cosine_Similarity": 0.31455862522125244,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5343",
            "BERTScore Recall": "0.4679",
            "BERTScore F1": "0.4989"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/ioquake/ioq3/commit/376267d534476a875d8b9228149c4ee18b74a4fd",
        "CVE ID": "CVE-2017-6903",
        "CVE Details": "In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",
        "CWE ID": "CWE-269",
        "commit_message": "Don't load .pk3s as .dlls, and don't load user config files from .pk3s.",
        "fixed_function": "void CL_InitRef( void ) {\n\trefimport_t\tri;\n\trefexport_t\t*ret;\n#ifdef USE_RENDERER_DLOPEN\n\tGetRefAPI_t\t\tGetRefAPI;\n\tchar\t\t\tdllName[MAX_OSPATH];\n#endif\n\n \tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n \n #ifdef USE_RENDERER_DLOPEN\n\tcl_renderer = Cvar_Get(\"cl_renderer\", \"opengl2\", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);\n \n \tCom_sprintf(dllName, sizeof(dllName), \"renderer_%s_\" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n\tif(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))\n\t{\n\t\tCom_Printf(\"failed:\\n\\\"%s\\\"\\n\", Sys_LibraryError());\n\t\tCvar_ForceReset(\"cl_renderer\");\n\n\t\tCom_sprintf(dllName, sizeof(dllName), \"renderer_opengl2_\" ARCH_STRING DLL_EXT);\n\t\trendererLib = Sys_LoadDll(dllName, qfalse);\n\t}\n\n\tif(!rendererLib)\n\t{\n\t\tCom_Printf(\"failed:\\n\\\"%s\\\"\\n\", Sys_LibraryError());\n\t\tCom_Error(ERR_FATAL, \"Failed to load renderer\");\n\t}\n\n\tGetRefAPI = Sys_LoadFunction(rendererLib, \"GetRefAPI\");\n\tif(!GetRefAPI)\n\t{\n\t\tCom_Error(ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\",  Sys_LibraryError());\n\t}\n#endif\n\n\tri.Cmd_AddCommand = Cmd_AddCommand;\n\tri.Cmd_RemoveCommand = Cmd_RemoveCommand;\n\tri.Cmd_Argc = Cmd_Argc;\n\tri.Cmd_Argv = Cmd_Argv;\n\tri.Cmd_ExecuteText = Cbuf_ExecuteText;\n\tri.Printf = CL_RefPrintf;\n\tri.Error = Com_Error;\n\tri.Milliseconds = CL_ScaledMilliseconds;\n\tri.Malloc = CL_RefMalloc;\n\tri.Free = Z_Free;\n#ifdef HUNK_DEBUG\n\tri.Hunk_AllocDebug = Hunk_AllocDebug;\n#else\n\tri.Hunk_Alloc = Hunk_Alloc;\n#endif\n\tri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;\n\tri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;\n\n\tri.CM_ClusterPVS = CM_ClusterPVS;\n\tri.CM_DrawDebugSurface = CM_DrawDebugSurface;\n\n\tri.FS_ReadFile = FS_ReadFile;\n\tri.FS_FreeFile = FS_FreeFile;\n\tri.FS_WriteFile = FS_WriteFile;\n\tri.FS_FreeFileList = FS_FreeFileList;\n\tri.FS_ListFiles = FS_ListFiles;\n\tri.FS_FileIsInPAK = FS_FileIsInPAK;\n\tri.FS_FileExists = FS_FileExists;\n\tri.Cvar_Get = Cvar_Get;\n\tri.Cvar_Set = Cvar_Set;\n\tri.Cvar_SetValue = Cvar_SetValue;\n\tri.Cvar_CheckRange = Cvar_CheckRange;\n\tri.Cvar_SetDescription = Cvar_SetDescription;\n\tri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;\n\n\n\tri.CIN_UploadCinematic = CIN_UploadCinematic;\n\tri.CIN_PlayCinematic = CIN_PlayCinematic;\n\tri.CIN_RunCinematic = CIN_RunCinematic;\n  \n\tri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;\n\n\tri.IN_Init = IN_Init;\n\tri.IN_Shutdown = IN_Shutdown;\n\tri.IN_Restart = IN_Restart;\n\n\tri.ftol = Q_ftol;\n\n\tri.Sys_SetEnv = Sys_SetEnv;\n\tri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;\n\tri.Sys_GLimpInit = Sys_GLimpInit;\n\tri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;\n\n\tret = GetRefAPI( REF_API_VERSION, &ri );\n\n#if defined __USEA3D && defined __A3D_GEOM\n\thA3Dg_ExportRenderGeom (ret);\n#endif\n\n\tCom_Printf( \"-------------------------------\\n\");\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = *ret;\n\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n",
        "vul_function": "void CL_InitRef( void ) {\n\trefimport_t\tri;\n\trefexport_t\t*ret;\n#ifdef USE_RENDERER_DLOPEN\n\tGetRefAPI_t\t\tGetRefAPI;\n\tchar\t\t\tdllName[MAX_OSPATH];\n#endif\n\n \tCom_Printf( \"----- Initializing Renderer ----\\n\" );\n \n #ifdef USE_RENDERER_DLOPEN\n\tcl_renderer = Cvar_Get(\"cl_renderer\", \"opengl2\", CVAR_ARCHIVE | CVAR_LATCH);\n \n \tCom_sprintf(dllName, sizeof(dllName), \"renderer_%s_\" ARCH_STRING DLL_EXT, cl_renderer->string);\n \n\tif(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString))\n\t{\n\t\tCom_Printf(\"failed:\\n\\\"%s\\\"\\n\", Sys_LibraryError());\n\t\tCvar_ForceReset(\"cl_renderer\");\n\n\t\tCom_sprintf(dllName, sizeof(dllName), \"renderer_opengl2_\" ARCH_STRING DLL_EXT);\n\t\trendererLib = Sys_LoadDll(dllName, qfalse);\n\t}\n\n\tif(!rendererLib)\n\t{\n\t\tCom_Printf(\"failed:\\n\\\"%s\\\"\\n\", Sys_LibraryError());\n\t\tCom_Error(ERR_FATAL, \"Failed to load renderer\");\n\t}\n\n\tGetRefAPI = Sys_LoadFunction(rendererLib, \"GetRefAPI\");\n\tif(!GetRefAPI)\n\t{\n\t\tCom_Error(ERR_FATAL, \"Can't load symbol GetRefAPI: '%s'\",  Sys_LibraryError());\n\t}\n#endif\n\n\tri.Cmd_AddCommand = Cmd_AddCommand;\n\tri.Cmd_RemoveCommand = Cmd_RemoveCommand;\n\tri.Cmd_Argc = Cmd_Argc;\n\tri.Cmd_Argv = Cmd_Argv;\n\tri.Cmd_ExecuteText = Cbuf_ExecuteText;\n\tri.Printf = CL_RefPrintf;\n\tri.Error = Com_Error;\n\tri.Milliseconds = CL_ScaledMilliseconds;\n\tri.Malloc = CL_RefMalloc;\n\tri.Free = Z_Free;\n#ifdef HUNK_DEBUG\n\tri.Hunk_AllocDebug = Hunk_AllocDebug;\n#else\n\tri.Hunk_Alloc = Hunk_Alloc;\n#endif\n\tri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory;\n\tri.Hunk_FreeTempMemory = Hunk_FreeTempMemory;\n\n\tri.CM_ClusterPVS = CM_ClusterPVS;\n\tri.CM_DrawDebugSurface = CM_DrawDebugSurface;\n\n\tri.FS_ReadFile = FS_ReadFile;\n\tri.FS_FreeFile = FS_FreeFile;\n\tri.FS_WriteFile = FS_WriteFile;\n\tri.FS_FreeFileList = FS_FreeFileList;\n\tri.FS_ListFiles = FS_ListFiles;\n\tri.FS_FileIsInPAK = FS_FileIsInPAK;\n\tri.FS_FileExists = FS_FileExists;\n\tri.Cvar_Get = Cvar_Get;\n\tri.Cvar_Set = Cvar_Set;\n\tri.Cvar_SetValue = Cvar_SetValue;\n\tri.Cvar_CheckRange = Cvar_CheckRange;\n\tri.Cvar_SetDescription = Cvar_SetDescription;\n\tri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue;\n\n\n\tri.CIN_UploadCinematic = CIN_UploadCinematic;\n\tri.CIN_PlayCinematic = CIN_PlayCinematic;\n\tri.CIN_RunCinematic = CIN_RunCinematic;\n  \n\tri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame;\n\n\tri.IN_Init = IN_Init;\n\tri.IN_Shutdown = IN_Shutdown;\n\tri.IN_Restart = IN_Restart;\n\n\tri.ftol = Q_ftol;\n\n\tri.Sys_SetEnv = Sys_SetEnv;\n\tri.Sys_GLimpSafeInit = Sys_GLimpSafeInit;\n\tri.Sys_GLimpInit = Sys_GLimpInit;\n\tri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory;\n\n\tret = GetRefAPI( REF_API_VERSION, &ri );\n\n#if defined __USEA3D && defined __A3D_GEOM\n\thA3Dg_ExportRenderGeom (ret);\n#endif\n\n\tCom_Printf( \"-------------------------------\\n\");\n\n\tif ( !ret ) {\n\t\tCom_Error (ERR_FATAL, \"Couldn't initialize refresh\" );\n\t}\n\n\tre = *ret;\n\n\tCvar_Set( \"cl_paused\", \"0\" );\n}\n",
        "llama3.1 Summary": "The patch removes the loading of renderer libraries from .pk3 archives, which prevents potential code injection vulnerabilities by ensuring that user-configured settings are not loaded from these files.",
        "llama3.1 CWE": "CWE-426",
        "llama3.1 CVE": "CVE-2021-XXXX-XXXX",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.6055",
            "BERTScore Recall": "0.5040",
            "BERTScore F1": "0.5501"
        },
        "llama3.1 Cosine_Similarity": 0.34373992681503296,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.007130444049835205,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3001",
            "BERTScore Recall": "0.2141",
            "BERTScore F1": "0.2499"
        },
        "Tokens Used": ""
    }
]