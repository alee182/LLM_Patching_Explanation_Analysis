[
    {
        "num": 1,
        "codeLink": "https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce",
        "CVE ID": "CVE-2016-3760",
        "CVE Details": "Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683.",
        "CWE ID": "CWE-20",
        "commit_message": "Add guest mode functionality (2/3)\n\nAdd a flag to enable() to start Bluetooth in restricted\nmode. In restricted mode, all devices that are paired during\nrestricted mode are deleted upon leaving restricted mode.\nRight now restricted mode is only entered while a guest\nuser is active.\n\nBug: 27410683\nChange-Id: I8f23d28ef0aa3a8df13d469c73005c8e1b894d19\n",
        "fixed_function": " static int remove_bond(const bt_bdaddr_t *bd_addr)\n {\n    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))\n        return BT_STATUS_SUCCESS;\n\n     /* sanity check */\n     if (interface_ready() == FALSE)\n         return BT_STATUS_NOT_READY;\n\n return btif_dm_remove_bond(bd_addr);\n}\n",
        "vul_function": " static int remove_bond(const bt_bdaddr_t *bd_addr)\n {\n     /* sanity check */\n     if (interface_ready() == FALSE)\n         return BT_STATUS_NOT_READY;\n\n return btif_dm_remove_bond(bd_addr);\n}\n",
        "llama3.1 Summary": "The patch removes a check to ensure that devices paired in restricted mode are deleted when the user leaves restricted mode, fixing a vulnerability where such devices were not being properly removed. This was done to align with the functionality described in the commit message and fix bug 27410683. Fixed version of function: static int remove_bond(const bt_bdaddr_t *bd_addr) { if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr)) return BT_STATUS_SUCCESS; /* sanity check */ if (interface_ready() == FALSE) return BT_STATUS_NOT_READY; return btif_dm_remove_bond(bd_addr); }",
        "llama3.1 CWE": "CWE-287",
        "llama3.1 CVE": "CVE-2015-XXXXXX",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4468",
            "BERTScore Recall": "0.5220",
            "BERTScore F1": "0.4815"
        },
        "llama3.1 Cosine_Similarity": 0.649094820022583,
        "Mistral Summary": "The patch adds a check to ensure that only devices paired during restricted mode are deleted when leaving the restricted mode. This change aims to prevent unauthorized access by ensuring proper access control over Bluetooth device management.",
        "Mistral CWE": "CWE-287 (Improper Access Control)",
        "Mistral CVE": "CVE-XXXX-XXXX (assigned upon disclosure of the vulnerability, not provided in this context)",
        "Mistral Cosine_Similarity": 0.6486908197402954,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5682",
            "BERTScore Recall": "0.4662",
            "BERTScore F1": "0.5122"
        },
        "Tokens Used": ""
    },
    {
        "num": 2,
        "codeLink": "https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac",
        "CVE ID": "CVE-2016-1586",
        "CVE Details": "A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.",
        "CWE ID": "CWE-20",
        "commit_message": "None",
        "fixed_function": "oxide::BrowserContext* WebContext::GetContext() {\nBrowserContext* WebContext::GetContext() {\n   if (context_.get()) {\n     return context_.get();\n   }\n \n   DCHECK(construct_props_);\n \n  BrowserContext::Params params(\n       construct_props_->data_path,\n       construct_props_->cache_path,\n       construct_props_->max_cache_size_hint,\n       construct_props_->session_cookie_mode);\n   params.host_mapping_rules = construct_props_->host_mapping_rules;\n \n  context_ = BrowserContext::Create(params);\n \n   UserAgentSettings* ua_settings = UserAgentSettings::Get(context_.get());\n  if (!construct_props_->product.empty()) {\n    ua_settings->SetProduct(construct_props_->product);\n  }\n  if (!construct_props_->user_agent.empty()) {\n    ua_settings->SetUserAgent(construct_props_->user_agent);\n  }\n  if (!construct_props_->accept_langs.empty()) {\n    ua_settings->SetAcceptLangs(construct_props_->accept_langs);\n  }\n  ua_settings->SetUserAgentOverrides(construct_props_->user_agent_overrides);\n  ua_settings->SetLegacyUserAgentOverrideEnabled(\n      construct_props_->legacy_user_agent_override_enabled);\n\n  context_->SetCookiePolicy(construct_props_->cookie_policy);\n  context_->SetIsPopupBlockerEnabled(construct_props_->popup_blocker_enabled);\n  context_->SetDoNotTrack(construct_props_->do_not_track);\n\n  MediaCaptureDevicesContext* dc =\n      MediaCaptureDevicesContext::Get(context_.get());\n\n  if (!construct_props_->default_audio_capture_device_id.empty()) {\n    if (!dc->SetDefaultAudioDeviceId(\n        construct_props_->default_audio_capture_device_id)) {\n      client_->DefaultAudioCaptureDeviceChanged();\n    }\n  }\n  if (!construct_props_->default_video_capture_device_id.empty()) {\n    if (!dc->SetDefaultVideoDeviceId(\n        construct_props_->default_video_capture_device_id)) {\n      client_->DefaultVideoCaptureDeviceChanged();\n    }\n  }\n\n  dc->set_client(this);\n\n  DevToolsManager* devtools = DevToolsManager::Get(context_.get());\n  if (!construct_props_->devtools_ip.empty()) {\n    devtools->SetAddress(construct_props_->devtools_ip);\n  }\n  if (construct_props_->devtools_port != -1) {\n    devtools->SetPort(construct_props_->devtools_port);\n  }\n  devtools->SetEnabled(construct_props_->devtools_enabled);\n\n  context_->SetDelegate(delegate_.get());\n\n  construct_props_.reset();\n\n  UpdateUserScripts();\n\n  return context_.get();\n}\n",
        "vul_function": "oxide::BrowserContext* WebContext::GetContext() {\n   if (context_.get()) {\n     return context_.get();\n   }\n \n   DCHECK(construct_props_);\n \n  oxide::BrowserContext::Params params(\n       construct_props_->data_path,\n       construct_props_->cache_path,\n       construct_props_->max_cache_size_hint,\n       construct_props_->session_cookie_mode);\n   params.host_mapping_rules = construct_props_->host_mapping_rules;\n \n  context_ = oxide::BrowserContext::Create(params);\n \n   UserAgentSettings* ua_settings = UserAgentSettings::Get(context_.get());\n  if (!construct_props_->product.empty()) {\n    ua_settings->SetProduct(construct_props_->product);\n  }\n  if (!construct_props_->user_agent.empty()) {\n    ua_settings->SetUserAgent(construct_props_->user_agent);\n  }\n  if (!construct_props_->accept_langs.empty()) {\n    ua_settings->SetAcceptLangs(construct_props_->accept_langs);\n  }\n  ua_settings->SetUserAgentOverrides(construct_props_->user_agent_overrides);\n  ua_settings->SetLegacyUserAgentOverrideEnabled(\n      construct_props_->legacy_user_agent_override_enabled);\n\n  context_->SetCookiePolicy(construct_props_->cookie_policy);\n  context_->SetIsPopupBlockerEnabled(construct_props_->popup_blocker_enabled);\n  context_->SetDoNotTrack(construct_props_->do_not_track);\n\n  MediaCaptureDevicesContext* dc =\n      MediaCaptureDevicesContext::Get(context_.get());\n\n  if (!construct_props_->default_audio_capture_device_id.empty()) {\n    if (!dc->SetDefaultAudioDeviceId(\n        construct_props_->default_audio_capture_device_id)) {\n      client_->DefaultAudioCaptureDeviceChanged();\n    }\n  }\n  if (!construct_props_->default_video_capture_device_id.empty()) {\n    if (!dc->SetDefaultVideoDeviceId(\n        construct_props_->default_video_capture_device_id)) {\n      client_->DefaultVideoCaptureDeviceChanged();\n    }\n  }\n\n  dc->set_client(this);\n\n  DevToolsManager* devtools = DevToolsManager::Get(context_.get());\n  if (!construct_props_->devtools_ip.empty()) {\n    devtools->SetAddress(construct_props_->devtools_ip);\n  }\n  if (construct_props_->devtools_port != -1) {\n    devtools->SetPort(construct_props_->devtools_port);\n  }\n  devtools->SetEnabled(construct_props_->devtools_enabled);\n\n  context_->SetDelegate(delegate_.get());\n\n  construct_props_.reset();\n\n  UpdateUserScripts();\n\n  return context_.get();\n}\n",
        "llama3.1 Summary": "The patch adds missing initialization for the `params` object, which was causing an undefined behavior when creating a new `BrowserContext`. This fix ensures that the necessary parameters are properly initialized before creating the context.",
        "llama3.1 CWE": "CWE-16",
        "llama3.1 CVE": "CVE-2023-1234",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5349",
            "BERTScore Recall": "0.5287",
            "BERTScore F1": "0.5318"
        },
        "llama3.1 Cosine_Similarity": 0.4301713705062866,
        "Mistral Summary": "The patch changes were applied to ensure that the data path and cache path passed to the BrowserContext::Params constructor are validated, preventing potential directory traversal attacks by restricting these paths to a secure location.",
        "Mistral CWE": "CWE-20 ( Improper Limitation of a Pathname to a Restricted Directory )",
        "Mistral CVE": "Not provided as no external impact is suggested in the given code",
        "Mistral Cosine_Similarity": 0.36284196376800537,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5885",
            "BERTScore Recall": "0.5543",
            "BERTScore F1": "0.5709"
        },
        "Tokens Used": ""
    },
    {
        "num": 3,
        "codeLink": "https://github.com/chromium/chromium/commit/e89cfcb9090e8c98129ae9160c513f504db74599",
        "CVE ID": "CVE-2012-5148",
        "CVE Details": "The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "Remove TabContents from TabStripModelObserver::TabDetachedAt.\n\nBUG=107201\nTEST=no visible change\n\n\nReview URL: https://chromiumcodereview.appspot.com/11293205\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@167122 0039d316-1c4b-4281-b951-d872f2087c98",
        "fixed_function": "void BrowserWindowGtk::UpdateDevToolsForContents(WebContents* contents) {\n  TRACE_EVENT0(\"ui::gtk\", \"BrowserWindowGtk::UpdateDevToolsForContents\");\n  DevToolsWindow* new_devtools_window = contents ?\n      DevToolsWindow::GetDockedInstanceForInspectedTab(contents) : NULL;\n\n  if (devtools_window_ == new_devtools_window && (!new_devtools_window ||\n        new_devtools_window->dock_side() == devtools_dock_side_))\n    return;\n \n   if (devtools_window_ != new_devtools_window) {\n    if (devtools_window_) {\n      devtools_container_->DetachTab(\n          devtools_window_->tab_contents()->web_contents());\n    }\n     devtools_container_->SetTab(\n         new_devtools_window ? new_devtools_window->tab_contents() : NULL);\n     if (new_devtools_window) {\n      new_devtools_window->tab_contents()->web_contents()->WasShown();\n    }\n  }\n\n  if (devtools_window_) {\n    GtkAllocation contents_rect;\n    gtk_widget_get_allocation(contents_vsplit_, &contents_rect);\n    if (devtools_dock_side_ == DEVTOOLS_DOCK_SIDE_RIGHT) {\n      devtools_window_->SetWidth(\n          contents_rect.width -\n          gtk_paned_get_position(GTK_PANED(contents_hsplit_)));\n    } else {\n      devtools_window_->SetHeight(\n          contents_rect.height -\n          gtk_paned_get_position(GTK_PANED(contents_vsplit_)));\n    }\n  }\n\n  bool should_hide = devtools_window_ && (!new_devtools_window ||\n      devtools_dock_side_ != new_devtools_window->dock_side());\n  bool should_show = new_devtools_window && (!devtools_window_ || should_hide);\n\n  if (should_hide)\n    HideDevToolsContainer();\n\n  devtools_window_ = new_devtools_window;\n\n  if (should_show) {\n    devtools_dock_side_ = new_devtools_window->dock_side();\n    ShowDevToolsContainer();\n  } else if (new_devtools_window) {\n    UpdateDevToolsSplitPosition();\n  }\n}\n",
        "vul_function": "void BrowserWindowGtk::UpdateDevToolsForContents(WebContents* contents) {\n  TRACE_EVENT0(\"ui::gtk\", \"BrowserWindowGtk::UpdateDevToolsForContents\");\n  DevToolsWindow* new_devtools_window = contents ?\n      DevToolsWindow::GetDockedInstanceForInspectedTab(contents) : NULL;\n\n  if (devtools_window_ == new_devtools_window && (!new_devtools_window ||\n        new_devtools_window->dock_side() == devtools_dock_side_))\n    return;\n \n   if (devtools_window_ != new_devtools_window) {\n    if (devtools_window_)\n      devtools_container_->DetachTab(devtools_window_->tab_contents());\n     devtools_container_->SetTab(\n         new_devtools_window ? new_devtools_window->tab_contents() : NULL);\n     if (new_devtools_window) {\n      new_devtools_window->tab_contents()->web_contents()->WasShown();\n    }\n  }\n\n  if (devtools_window_) {\n    GtkAllocation contents_rect;\n    gtk_widget_get_allocation(contents_vsplit_, &contents_rect);\n    if (devtools_dock_side_ == DEVTOOLS_DOCK_SIDE_RIGHT) {\n      devtools_window_->SetWidth(\n          contents_rect.width -\n          gtk_paned_get_position(GTK_PANED(contents_hsplit_)));\n    } else {\n      devtools_window_->SetHeight(\n          contents_rect.height -\n          gtk_paned_get_position(GTK_PANED(contents_vsplit_)));\n    }\n  }\n\n  bool should_hide = devtools_window_ && (!new_devtools_window ||\n      devtools_dock_side_ != new_devtools_window->dock_side());\n  bool should_show = new_devtools_window && (!devtools_window_ || should_hide);\n\n  if (should_hide)\n    HideDevToolsContainer();\n\n  devtools_window_ = new_devtools_window;\n\n  if (should_show) {\n    devtools_dock_side_ = new_devtools_window->dock_side();\n    ShowDevToolsContainer();\n  } else if (new_devtools_window) {\n    UpdateDevToolsSplitPosition();\n  }\n}\n",
        "llama3.1 Summary": "The patch fixes a potential null pointer dereference by checking for NULL before calling methods on the new_devtools_window object. This was applied to prevent crashes due to incorrect handling of certain scenarios where devtools_window_ and new_devtools_window could be NULL or mismatched in dock side configuration. Fixed version of function: void BrowserWindowGtk::UpdateDevToolsForContents(WebContents* contents) { ... }",
        "llama3.1 CWE": "CWE-94",
        "llama3.1 CVE": "CVE-2012-5513",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4733",
            "BERTScore Recall": "0.5347",
            "BERTScore F1": "0.5021"
        },
        "llama3.1 Cosine_Similarity": 0.3488783836364746,
        "Mistral Summary": "The patch removes the call to `devtools_container_->DetachTab(devtools_window_->tab_contents())` when detaching a tab from the tab strip model observer. This change was applied to fix a race condition that could lead to a use-after-free vulnerability in the vulnerable code version. The detached tab was not properly removed, potentially allowing it to be reused and accessed after it had been freed, leading to unpredictable behavior and potential security impacts.",
        "Mistral CWE": "CWE-476",
        "Mistral CVE": "CVE-YYYY-XXXX (This is a placeholder, as the specific CVE ID depends on the date and other factors. The vulnerability analyst would need to check the Chromium security advisories or contact the project team for the correct CVE ID.)",
        "Mistral Cosine_Similarity": 0.3190877437591553,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.4984",
            "BERTScore Recall": "0.5639",
            "BERTScore F1": "0.5292"
        },
        "Tokens Used": ""
    },
    {
        "num": 4,
        "codeLink": "https://github.com/chromium/chromium/commit/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7",
        "CVE ID": "CVE-2011-2839",
        "CVE Details": "The PDF implementation in Google Chrome before 13.0.782.215 on Linux does not properly use the memset library function, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "Extend TTS extension API to support richer events returned from the engine\nto the client. Previously we just had a completed event; this adds start,\nword boundary, sentence boundary, and marker boundary. In addition,\ninterrupted and canceled, which were previously errors, now become events.\nMac and Windows implementations extended to support as many of these events\nas possible.\n\nBUG=67713\nBUG=70198\nBUG=75106\nBUG=83404\n\nTEST=Updates all TTS API tests to be event-based, and adds new tests.\nReview URL: http://codereview.chromium.org/6792014\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@91665 0039d316-1c4b-4281-b951-d872f2087c98",
        "fixed_function": "void ExtensionTtsController::OnSpeechFinished(\n",
        "vul_function": "void ExtensionTtsController::OnSpeechFinished(\n    int request_id, const std::string& error_message) {\n  if (!current_utterance_ || request_id != current_utterance_->id())\n    return;\n  current_utterance_->set_error(error_message);\n  FinishCurrentUtterance();\n  SpeakNextUtterance();\n}\n",
        "llama3.1 Summary": "The patch changes the error handling mechanism by converting previously handled errors into events, allowing for more robust and flexible handling of interrupt or cancellation. This change was applied to improve the TTS extension API's ability to handle richer events returned from the engine to the client.\n\nvoid ExtensionTtsController::OnSpeechFinished(\n Vulnerable version of function: void ExtensionTtsController::OnSpeechFinished(\n    int request_id, const std::string& error_message) {\n  if (!current_utterance_ || request_id != current_utterance_->id())\n    return;\n  current_utterance_->set_error(error_message);\n  FinishCurrentUtterance();\n  SpeakNextUtterance();\n}",
        "llama3.1 CWE": "CWE-918",
        "llama3.1 CVE": "CVE-2015-1293",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3869",
            "BERTScore Recall": "0.5380",
            "BERTScore F1": "0.4501"
        },
        "llama3.1 Cosine_Similarity": 0.21138375997543335,
        "Mistral Summary": "The patch extends the TTS extension API to support richer events returned from the engine, which were previously errors. This change transforms interruption and cancellation events from errors into events. The vulnerable function did not properly handle these events, potentially leading to incorrect error processing or unintended function execution. The updated function now handles a wider range of events, improving the robustness and flexibility of the TTS extension.",
        "Mistral CWE": "CWE-20",
        "Mistral CVE": "N/A (There is no publicly disclosed vulnerability associated with this code change, as it is a design issue related to event handling rather than a security flaw)",
        "Mistral Cosine_Similarity": 0.31758493185043335,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5356",
            "BERTScore Recall": "0.5689",
            "BERTScore F1": "0.5517"
        },
        "Tokens Used": ""
    },
    {
        "num": 5,
        "codeLink": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "CVE ID": "CVE-2017-15951",
        "CVE Details": "The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the \"negative\" state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls.",
        "CWE ID": "CWE-20",
        "commit_message": "KEYS: Fix race between updating and finding a negative key\n\nConsolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection\nerror into one field such that:\n\n (1) The instantiation state can be modified/read atomically.\n\n (2) The error can be accessed atomically with the state.\n\n (3) The error isn't stored unioned with the payload pointers.\n\nThis deals with the problem that the state is spread over three different\nobjects (two bits and a separate variable) and reading or updating them\natomically isn't practical, given that not only can uninstantiated keys\nchange into instantiated or rejected keys, but rejected keys can also turn\ninto instantiated keys - and someone accessing the key might not be using\nany locking.\n\nThe main side effect of this problem is that what was held in the payload\nmay change, depending on the state.  For instance, you might observe the\nkey to be in the rejected state.  You then read the cached error, but if\nthe key semaphore wasn't locked, the key might've become instantiated\nbetween the two reads - and you might now have something in hand that isn't\nactually an error code.\n\nThe state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error\ncode if the key is negatively instantiated.  The key_is_instantiated()\nfunction is replaced with key_is_positive() to avoid confusion as negative\nkeys are also 'instantiated'.\n\nAdditionally, barriering is included:\n\n (1) Order payload-set before state-set during instantiation.\n\n (2) Order state-read before payload-read when using the key.\n\nFurther separate barriering is necessary if RCU is being used to access the\npayload content after reading the payload pointers.\n\nFixes: 146aa8b1453b (\"KEYS: Merge the type-specific data with the payload data\")\nCc: stable@vger.kernel.org # v4.4+\nReported-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>",
        "fixed_function": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n \t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n \tif (ret)\n \t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n \treturn key_validate(key);\n }\n",
        "vul_function": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n \t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n \tif (ret)\n \t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n \treturn key_validate(key);\n }\n",
        "llama3.1 Summary": "The patch consolidates the key's instantiation state and rejection error into a single field, accessed atomically to prevent races between updating and finding a negative key. This change addresses a problem where the state was spread across three different objects, making it impractical to read or update them atomically, which could lead to observing an inconsistent key state.",
        "llama3.1 CWE": "CWE-362",
        "llama3.1 CVE": "CVE-2017-7538",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.6014",
            "BERTScore Recall": "0.5959",
            "BERTScore F1": "0.5987"
        },
        "llama3.1 Cosine_Similarity": 0.5751919746398926,
        "Mistral Summary": "The patch addresses a race condition between updating and finding a negative key by consolidating multiple flags into one field to ensure atomic modification/reading of the state. This prevents inconsistencies in the key's state that could lead to incorrect error codes being read.",
        "Mistral CWE": "CWE-362 (Race Condition)",
        "Mistral CVE": "Not applicable as the CVE ID is assigned by a trusted entity such as MITRE or NVD, and it's based on various factors including the affected product, the vendor, and the disclosure status.",
        "Mistral Cosine_Similarity": 0.5940160751342773,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.6662",
            "BERTScore Recall": "0.6237",
            "BERTScore F1": "0.6443"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1",
        "CVE ID": "CVE-2013-1828",
        "CVE Details": "The sctp_getsockopt_assoc_stats function in net/sctp/socket.c in the Linux kernel before 3.8.4 does not validate a size value before proceeding to a copy_from_user operation, which allows local users to gain privileges via a crafted application that contains an SCTP_GET_ASSOC_STATS getsockopt system call.",
        "CWE ID": "CWE-20",
        "commit_message": "net/sctp: Validate parameter size for SCTP_GET_ASSOC_STATS\n\nBuilding sctp may fail with:\n\nIn function \u2018copy_from_user\u2019,\n    inlined from \u2018sctp_getsockopt_assoc_stats\u2019 at\n    net/sctp/socket.c:5656:20:\narch/x86/include/asm/uaccess_32.h:211:26: error: call to\n    \u2018copy_from_user_overflow\u2019 declared with attribute error: copy_from_user()\n    buffer size is not provably correct\n\nif built with W=1 due to a missing parameter size validation\nbefore the call to copy_from_user.\n\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "fixed_function": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "vul_function": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "llama3.1 Summary": "The patch added validation for the parameter size before calling copy_from_user to prevent an overflow and fix a bug that caused building sctp to fail with a 'copy_from_user_overflow' error. This change ensures that the user-provided buffer size is correct, preventing potential attacks that could have been exploited by malicious users. Fixed version of function: static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n \t/* Mark beginning of a new observation period */\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "llama3.1 CWE": "CWE-194",
        "llama3.1 CVE": "CVE-2014-3673",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4227",
            "BERTScore Recall": "0.5384",
            "BERTScore F1": "0.4736"
        },
        "llama3.1 Cosine_Similarity": 0.7285848259925842,
        "Mistral Summary": null,
        "Mistral CWE": "CWE-190 (Buffer Copy Without Checking Size of Input)",
        "Mistral CVE": "Not directly provided, it depends on the version and distribution of Linux where this patch is applied\n\nThe reason for this identification is that the original code does not check the size of the buffer before copying data from it using `copy_from_user()`. This can lead to a buffer overflow if an attacker provides larger data than expected. The patch addresses this issue by adding a validation step, ensuring the parameter size is correct before the call to `copy_from_user()`.",
        "Mistral Cosine_Similarity": 0.06443345546722412,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3194",
            "BERTScore Recall": "0.2111",
            "BERTScore F1": "0.2542"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e",
        "CVE ID": "CVE-2017-12187",
        "CVE Details": "xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.",
        "CWE ID": "CWE-20",
        "commit_message": "None",
        "fixed_function": "XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n    Bool send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n    send_event = stuff->send_event;\n\n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\n    result = dixLookupResourceByType((void **) &gc, stuff->gc,\n                                     XRT_GC, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = dixLookupResourceByType((void **) &port, stuff->port,\n                                     XvXRTPort, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;\n\n    x = stuff->drw_x;\n    y = stuff->drw_y;\n\n    FOR_NSCREENS_BACKWARD(i) {\n        if (port->info[i].id) {\n            stuff->drawable = draw->info[i].id;\n            stuff->port = port->info[i].id;\n            stuff->gc = gc->info[i].id;\n            stuff->drw_x = x;\n            stuff->drw_y = y;\n            if (isRoot) {\n                stuff->drw_x -= screenInfo.screens[i]->x;\n                stuff->drw_y -= screenInfo.screens[i]->y;\n            }\n            stuff->send_event = (send_event && !i) ? 1 : 0;\n\n            result = ProcXvShmPutImage(client);\n        }\n    }\n    return result;\n}\n",
        "vul_function": "XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n    Bool send_event = stuff->send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\n    result = dixLookupResourceByType((void **) &gc, stuff->gc,\n                                     XRT_GC, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = dixLookupResourceByType((void **) &port, stuff->port,\n                                     XvXRTPort, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;\n\n    x = stuff->drw_x;\n    y = stuff->drw_y;\n\n    FOR_NSCREENS_BACKWARD(i) {\n        if (port->info[i].id) {\n            stuff->drawable = draw->info[i].id;\n            stuff->port = port->info[i].id;\n            stuff->gc = gc->info[i].id;\n            stuff->drw_x = x;\n            stuff->drw_y = y;\n            if (isRoot) {\n                stuff->drw_x -= screenInfo.screens[i]->x;\n                stuff->drw_y -= screenInfo.screens[i]->y;\n            }\n            stuff->send_event = (send_event && !i) ? 1 : 0;\n\n            result = ProcXvShmPutImage(client);\n        }\n    }\n    return result;\n}\n",
        "llama3.1 Summary": "The patch adds a check to ensure that the 'send_event' field is not accessed before it has been initialized, preventing a null pointer dereference. This change was applied to prevent potential crashes or undefined behavior caused by uninitialized variables.",
        "llama3.1 CWE": "CWE-129",
        "llama3.1 CVE": "CVE-2009-3555",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5691",
            "BERTScore Recall": "0.5854",
            "BERTScore F1": "0.5771"
        },
        "llama3.1 Cosine_Similarity": 0.3561364412307739,
        "Mistral Summary": "The patch changes the hard-coded resource access values in the function to dynamically look up the resources based on the current screen context. This was applied to prevent the use of hard-coded credentials, which can lead to unauthorized access if intercepted or exposed.",
        "Mistral CWE": "CWE-200 (Use of a Hard-coded Credential)",
        "Mistral CVE": "Not applicable, as there is no publicly disclosed vulnerability associated with this code snippet and commit message does not contain any information about an external resource being used.",
        "Mistral Cosine_Similarity": 0.3081134557723999,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5548",
            "BERTScore Recall": "0.5706",
            "BERTScore F1": "0.5626"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e",
        "CVE ID": "CVE-2017-17805",
        "CVE Details": "The Salsa20 encryption algorithm in the Linux kernel before 4.14.8 does not correctly handle zero-length inputs, allowing a local attacker able to use the AF_ALG-based skcipher interface (CONFIG_CRYPTO_USER_API_SKCIPHER) to cause a denial of service (uninitialized-memory free and kernel crash) or have unspecified other impact by executing a crafted sequence of system calls that use the blkcipher_walk API. Both the generic implementation (crypto/salsa20_generic.c) and x86 implementation (arch/x86/crypto/salsa20_glue.c) of Salsa20 were vulnerable.",
        "CWE ID": "CWE-20",
        "commit_message": "crypto: salsa20 - fix blkcipher_walk API usage\n\nWhen asked to encrypt or decrypt 0 bytes, both the generic and x86\nimplementations of Salsa20 crash in blkcipher_walk_done(), either when\ndoing 'kfree(walk->buffer)' or 'free_page((unsigned long)walk->page)',\nbecause walk->buffer and walk->page have not been initialized.\n\nThe bug is that Salsa20 is calling blkcipher_walk_done() even when\nnothing is in 'walk.nbytes'.  But blkcipher_walk_done() is only meant to\nbe called when a nonzero number of bytes have been provided.\n\nThe broken code is part of an optimization that tries to make only one\ncall to salsa20_encrypt_bytes() to process inputs that are not evenly\ndivisible by 64 bytes.  To fix the bug, just remove this \"optimization\"\nand use the blkcipher_walk API the same way all the other users do.\n\nReproducer:\n\n    #include <linux/if_alg.h>\n    #include <sys/socket.h>\n    #include <unistd.h>\n\n    int main()\n    {\n            int algfd, reqfd;\n            struct sockaddr_alg addr = {\n                    .salg_type = \"skcipher\",\n                    .salg_name = \"salsa20\",\n            };\n            char key[16] = { 0 };\n\n            algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n            bind(algfd, (void *)&addr, sizeof(addr));\n            reqfd = accept(algfd, 0, 0);\n            setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));\n            read(reqfd, key, sizeof(key));\n    }\n\nReported-by: syzbot <syzkaller@googlegroups.com>\nFixes: eb6f13eb9f81 (\"[CRYPTO] salsa20_generic: Fix multi-page processing\")\nCc: <stable@vger.kernel.org> # v2.6.25+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "fixed_function": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
        "vul_function": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n",
        "llama3.1 Summary": "The patch removes an optimization in the salsa20 encryption function that incorrectly calls blkcipher_walk_done() when encrypting 0 bytes, leading to a crash. This fix ensures that blkcipher_walk_done() is only called when a nonzero number of bytes have been processed, aligning with its intended use. Fixed version of function: static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}",
        "llama3.1 CWE": "CWE-476",
        "llama3.1 CVE": "CVE-2013-4237",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4350",
            "BERTScore Recall": "0.5231",
            "BERTScore F1": "0.4750"
        },
        "llama3.1 Cosine_Similarity": 0.7269799113273621,
        "Mistral Summary": "The patch changes the usage of the `blkcipher_walk` API to ensure that it is only called when a nonzero number of bytes have been provided, preventing buffer access dereferencing and potential crashes.",
        "Mistral CWE": "CWE-189 (Buffer Access Dereference)",
        "Mistral CVE": "CVE-2021-35742",
        "Mistral Cosine_Similarity": 0.4713272452354431,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.6364",
            "BERTScore Recall": "0.5320",
            "BERTScore F1": "0.5796"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/3c8e4852477d5b1e2da877808c998dc57db9460f",
        "CVE ID": "CVE-2018-6111",
        "CVE Details": "An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.",
        "CWE ID": "CWE-20",
        "commit_message": "DevTools: speculative fix for crash in NetworkHandler::Disable\n\nThis keeps BrowserContext* and StoragePartition* instead of\nRenderProcessHost* in an attemp to resolve UAF of RenderProcessHost\nupon closure of DevTools front-end.\n\nBug: 801117, 783067, 780694\nChange-Id: I6c2cca60cc0c29f0949d189cf918769059f80c1b\nReviewed-on: https://chromium-review.googlesource.com/876657\nCommit-Queue: Andrey Kosyakov <caseq@chromium.org>\nReviewed-by: Dmitry Gozman <dgozman@chromium.org>\nCr-Commit-Position: refs/heads/master@{#531157}",
        "fixed_function": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(worker_process_id_, nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n",
        "vul_function": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),\n                         nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n",
        "llama3.1 Summary": "The patch changes the type of pointer used in the AttachSession function to prevent use-after-free (UAF) issues, which could cause a crash when the DevTools front-end is closed. This was applied because it resolves several related bugs (801117, 783067, 780694), which were causing crashes due to the UAF issue. Fixed version of function: void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {   if (state_ == WORKER_READY) {     if (sessions().size() == 1) {       BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,                            base::BindOnce(&SetDevToolsAttachedOnIO,                                       context_weak_, version_id_, true));      }      session->SetRenderer(worker_process_id_, nullptr);      session->AttachToAgent(agent_ptr_);    }    session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler())); }",
        "llama3.1 CWE": "CWE-416",
        "llama3.1 CVE": "CVE-2018-6176",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3878",
            "BERTScore Recall": "0.6009",
            "BERTScore F1": "0.4714"
        },
        "llama3.1 Cosine_Similarity": 0.4721255302429199,
        "Mistral Summary": "The patch changes the RenderProcessHost* to BrowserContext* in order to prevent a Use After Free (UAF) of RenderProcessHost upon closure of DevTools front-end. The NetworkHandler, which was the potential source of the crash, is no longer affected by the UAF issue due to this change.",
        "Mistral CWE": "CWE-476 (Resource Leak)",
        "Mistral CVE": "Not applicable as it's a speculative fix and not confirmed to be exploitable",
        "Mistral Cosine_Similarity": 0.49962103366851807,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5246",
            "BERTScore Recall": "0.5604",
            "BERTScore F1": "0.5419"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://android.googlesource.com/platform/external/libvpx/+/cc274e2abe8b2a6698a5c47d8aa4bb45f1f9538d",
        "CVE ID": "CVE-2016-2464",
        "CVE Details": "libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726.",
        "CWE ID": "CWE-20",
        "commit_message": "external/libvpx/libwebm: Update snapshot\n\nUpdate libwebm snapshot. This update contains security fixes from upstream.\n\nUpstream git hash: 229f49347d19b0ca0941e072b199a242ef6c5f2b\n\nBUG=23167726\n\nChange-Id: Id3e140e7b31ae11294724b1ecfe2e9c83b4d4207\n(cherry picked from commit d0281a15b3c6bd91756e453cc9398c5ef412d99a)\n",
        "fixed_function": "long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,\nlong ParseElementHeader(IMkvReader* pReader, long long& pos,\n                        long long stop, long long& id,\n                        long long& size) {\n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   long len;\n \n  id = ReadID(pReader, pos, len);\n \n   if (id < 0)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  // consume id\n \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   size = ReadUInt(pReader, pos, len);\n \n  if (size < 0 || len < 1 || len > 8) {\n    // Invalid: Negative payload size, negative or 0 length integer, or integer\n    // larger than 64 bits (libwebm cannot handle them).\n    return E_FILE_FORMAT_INVALID;\n  }\n\n  // Avoid rolling over pos when very close to LONG_LONG_MAX.\n  const unsigned long long rollover_check =\n      static_cast<unsigned long long>(pos) + len;\n  if (rollover_check > LONG_LONG_MAX)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  // consume length of size\n \n \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  // success\n }\n",
        "vul_function": "long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,\n                                   long long stop, long long& id,\n                                   long long& size) {\n  if ((stop >= 0) && (pos >= stop))\n     return E_FILE_FORMAT_INVALID;\n \n   long len;\n \n  id = ReadUInt(pReader, pos, len);\n \n   if (id < 0)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  // consume id\n \n  if ((stop >= 0) && (pos >= stop))\n     return E_FILE_FORMAT_INVALID;\n \n   size = ReadUInt(pReader, pos, len);\n \n  if (size < 0)\n     return E_FILE_FORMAT_INVALID;\n \n   pos += len;  // consume length of size\n \n \n  if ((stop >= 0) && ((pos + size) > stop))\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  // success\n }\n",
        "llama3.1 Summary": "The patch changes the way the function handles invalid payload sizes, specifically adding a check to avoid rolling over `pos` when close to `LONG_LONG_MAX`, and fixes a potential buffer overflow by ensuring that `size` is not negative.",
        "llama3.1 CWE": "CWE-131",
        "llama3.1 CVE": "CVE-2020-1000111",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5178",
            "BERTScore Recall": "0.4848",
            "BERTScore F1": "0.5008"
        },
        "llama3.1 Cosine_Similarity": 0.31380295753479004,
        "Mistral Summary": "The patch changes the way the size variable is validated to prevent integer overflow. It now checks if the sum of pos (current position) and size would exceed LONG_LONG_MAX, which addresses the potential vulnerability in the vulnerable version where the size was only checked against stop. This modification ensures that the parser does not read beyond the expected file limit, improving the security of the application.",
        "Mistral CWE": "CWE-209 (Integer Overflow or Wraparound)",
        "Mistral CVE": "Not provided, as the specific vulnerability's CVE ID is not given in the commit message and will be assigned by a proper CVE numbering authority.",
        "Mistral Cosine_Similarity": 0.3484659194946289,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.4865",
            "BERTScore Recall": "0.4700",
            "BERTScore F1": "0.4781"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/df5b1e1f88e013bc96107cc52c4a4f33a8238444",
        "CVE ID": "CVE-2018-6085",
        "CVE Details": "Re-entry of a destructor in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.",
        "CWE ID": "CWE-20",
        "commit_message": "Blockfile cache: fix long-standing sparse + evict reentrancy problem\n\nThanks to nedwilliamson@ (on gmail) for an alternative perspective\nplus a reduction to make fixing this much easier.\n\nBug: 826626, 518908, 537063, 802886\nChange-Id: Ibfa01416f9a8e7f7b361e4f93b4b6b134728b85f\nReviewed-on: https://chromium-review.googlesource.com/985052\nReviewed-by: Matt Menke <mmenke@chromium.org>\nCommit-Queue: Maks Orlovich <morlovich@chromium.org>\nCr-Commit-Position: refs/heads/master@{#547103}",
        "fixed_function": "BackendImpl::BackendImpl(\n    const base::FilePath& path,\n    scoped_refptr<BackendCleanupTracker> cleanup_tracker,\n    const scoped_refptr<base::SingleThreadTaskRunner>& cache_thread,\n    net::NetLog* net_log)\n    : cleanup_tracker_(std::move(cleanup_tracker)),\n      background_queue_(this, FallbackToInternalIfNull(cache_thread)),\n      path_(path),\n      block_files_(path),\n      mask_(0),\n      max_size_(0),\n      up_ticks_(0),\n      cache_type_(net::DISK_CACHE),\n      uma_report_(0),\n      user_flags_(0),\n      init_(false),\n      restarted_(false),\n      unit_test_(false),\n      read_only_(false),\n      disabled_(false),\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n      consider_evicting_at_op_end_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n      ptr_factory_(this) {}\n",
        "vul_function": "BackendImpl::BackendImpl(\n    const base::FilePath& path,\n    scoped_refptr<BackendCleanupTracker> cleanup_tracker,\n    const scoped_refptr<base::SingleThreadTaskRunner>& cache_thread,\n    net::NetLog* net_log)\n    : cleanup_tracker_(std::move(cleanup_tracker)),\n      background_queue_(this, FallbackToInternalIfNull(cache_thread)),\n      path_(path),\n      block_files_(path),\n      mask_(0),\n      max_size_(0),\n      up_ticks_(0),\n      cache_type_(net::DISK_CACHE),\n      uma_report_(0),\n      user_flags_(0),\n      init_(false),\n      restarted_(false),\n      unit_test_(false),\n      read_only_(false),\n      disabled_(false),\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n      ptr_factory_(this) {}\n",
        "llama3.1 Summary": "The patch fixes a reentrancy issue where the cache's eviction mechanism could be triggered recursively, leading to potential crashes or data corruption. This was addressed by adding a flag to prevent recursive calls to evicting at operation end.",
        "llama3.1 CWE": "CWE-479",
        "llama3.1 CVE": "CVE-2012-2675",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5630",
            "BERTScore Recall": "0.5344",
            "BERTScore F1": "0.5484"
        },
        "llama3.1 Cosine_Similarity": 0.47930997610092163,
        "Mistral Summary": "The patch changes the initialization of the `path_` variable from using a copy to using a move, which prevents potential buffer overflow vulnerabilities caused by large or malicious input. This change addresses the long-standing sparse and eviction reentrancy problem reported in bugs 826626, 518908, 537063, and 802886.",
        "Mistral CWE": "CWE-20 (Buffer Copy Without Checking Size of Input)",
        "Mistral CVE": "CVE-YYYY-YYYY-YYYY (Not provided, should be generated by the organization managing the codebase)",
        "Mistral Cosine_Similarity": 0.41132134199142456,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5554",
            "BERTScore Recall": "0.5751",
            "BERTScore F1": "0.5651"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/f106eee10038c2ee5b6056aaf3f6d5229be6dcdd",
        "CVE ID": "CVE-2010-5328",
        "CVE Details": "include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group.",
        "CWE ID": "CWE-20",
        "commit_message": "pids: fix fork_idle() to setup ->pids correctly\n\ncopy_process(pid => &init_struct_pid) doesn't do attach_pid/etc.\n\nIt shouldn't, but this means that the idle threads run with the wrong\npids copied from the caller's task_struct. In x86 case the caller is\neither kernel_init() thread or keventd.\n\nIn particular, this means that after the series of cpu_up/cpu_down an\nidle thread (which never exits) can run with .pid pointing to nowhere.\n\nChange fork_idle() to initialize idle->pids[] correctly. We only set\n.pid = &init_struct_pid but do not add .node to list, INIT_TASK() does\nthe same for the boot-cpu idle thread (swapper).\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Cedric Le Goater <clg@fr.ibm.com>\nCc: Dave Hansen <haveblue@us.ibm.com>\nCc: Eric Biederman <ebiederm@xmission.com>\nCc: Herbert Poetzl <herbert@13thfloor.at>\nCc: Mathias Krause <Mathias.Krause@secunet.com>\nAcked-by: Roland McGrath <roland@redhat.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nCc: Sukadev Bhattiprolu <sukadev@us.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "fixed_function": " struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n \tstruct pt_regs regs;\n \n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n \t\tinit_idle(task, cpu);\n\t}\n \n \treturn task;\n }\n",
        "vul_function": " struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n \tstruct pt_regs regs;\n \n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n \t\tinit_idle(task, cpu);\n \n \treturn task;\n }\n",
        "llama3.1 Summary": "The patch changes the fork_idle function to correctly initialize the pids of newly created idle threads, preventing a potential dereference of a null pointer. This was done because idle threads were being started with pids pointing to nowhere after a series of cpu_up/cpu_down operations.\nFixed version of function: struct task_struct * __cpuinit fork_idle(int cpu)\n{\n    struct task_struct *task;\n    struct pt_regs regs;\n\n    task = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n                        &init_struct_pid, 0);\n    if (!IS_ERR(task)) {\n        init_idle_pids(task->pids);\n        init_idle(task, cpu);\n    }\n\n    return task;\n}",
        "llama3.1 CWE": "CWE-22",
        "llama3.1 CVE": "CVE-2009-1337",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3925",
            "BERTScore Recall": "0.5238",
            "BERTScore F1": "0.4487"
        },
        "llama3.1 Cosine_Similarity": 0.4423724412918091,
        "Mistral Summary": "The patch changes the initialization of the `pids` array in the `fork_idle()` function to ensure it's set up correctly. This addresses an issue where idle threads were running with incorrect `pid` values, which could lead to a resource leak or other unintended behavior.",
        "Mistral CWE": "CWE-207 (Improper Resource Release or Lifecycle Management)",
        "Mistral CVE": "CVE-YYYY-XXXX (Assigned by the appropriate authority after review and verification)",
        "Mistral Cosine_Similarity": 0.39593982696533203,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5876",
            "BERTScore Recall": "0.5852",
            "BERTScore F1": "0.5864"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://git.launchpad.net/oxide/commit/?id=29014da83e5fc358d6bff0f574e9ed45e61a35ac",
        "CVE ID": "CVE-2016-1586",
        "CVE Details": "A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.",
        "CWE ID": "CWE-20",
        "commit_message": "None",
        "fixed_function": "void BrowserContextDestroyer::DestroyContext(BrowserContext* context) {\nvoid BrowserContextDestroyer::Shutdown() {\n  auto destroy_all_unused_contexts = []() {\n    auto it = g_contexts_pending_deletion.Get().begin();\n    while (it != g_contexts_pending_deletion.Get().end()) {\n      BrowserContextDestroyer* destroyer = *it;\n      ++it;\n \n      if (!destroyer->finish_destroy_scheduled_) {\n        continue;\n      }\n \n      destroyer->FinishDestroyContext();\n      // |destroyer| is invalid now\n     }\n  };\n \n  // We make 2 passes over the list because the first pass can destroy an\n  // incognito BrowserContext that subsequently schedules its owner context for\n  // deletion\n  destroy_all_unused_contexts();\n  destroy_all_unused_contexts();\n}\n\n//// static\nvoid BrowserContextDestroyer::RenderProcessHostAssignedToSiteInstance(\n    content::RenderProcessHost* host) {\n  BrowserContextDestroyer* destroyer = GetForContext(host->GetBrowserContext());\n  if (!destroyer) {\n    return;\n   }\n \n  CHECK(!destroyer->finish_destroy_scheduled_);\n \n  if (destroyer->pending_host_ids_.find(host->GetID()) !=\n      destroyer->pending_host_ids_.end()) {\n    return;\n   }\n\n  destroyer->ObserveHost(host);\n }\n",
        "vul_function": "void BrowserContextDestroyer::DestroyContext(BrowserContext* context) {\n  CHECK(context->IsOffTheRecord() || !context->HasOffTheRecordContext());\n \n  content::BrowserContext::NotifyWillBeDestroyed(context);\n  std::set<content::RenderProcessHost*> hosts;\n \n  for (content::RenderProcessHost::iterator it =\n           content::RenderProcessHost::AllHostsIterator();\n       !it.IsAtEnd(); it.Advance()) {\n    content::RenderProcessHost* host = it.GetCurrentValue();\n    if (host->GetBrowserContext() != context) {\n      continue;\n     }\n \n    hosts.insert(host);\n//// static\n   }\n \n \n  if (hosts.empty()) {\n    delete context;\n  } else {\n    new BrowserContextDestroyer(context, hosts);\n   }\n }\n",
        "llama3.1 Summary": "The patch fixes a double-free vulnerability by ensuring that the `BrowserContextDestroyer` is not used after it has been finished destroying its context. This was applied to prevent potential crashes or unexpected behavior caused by accessing invalid memory.\n\nNote: Since no commit message is provided, I couldn't use it for identification.",
        "llama3.1 CWE": "CWE-476",
        "llama3.1 CVE": "None",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5238",
            "BERTScore Recall": "0.5580",
            "BERTScore F1": "0.5403"
        },
        "llama3.1 Cosine_Similarity": 0.42909711599349976,
        "Mistral Summary": "The patch changes the method for handling BrowserContext deletion by removing the hard-coded check for OffTheRecord contexts and replacing it with a scheduling system. This is to prevent the premature destruction of non-OffTheRecord contexts associated with RenderProcessHosts, ensuring proper cleanup of resources.",
        "Mistral CWE": "CWE-399 (Use of a Broken or Erroneous Algorithm)",
        "Mistral CVE": "N/A (Commit message does not provide specific vulnerability details for assigning a CVE ID)",
        "Mistral Cosine_Similarity": 0.4843099117279053,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5426",
            "BERTScore Recall": "0.5495",
            "BERTScore F1": "0.5460"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://android.googlesource.com/platform/external/libavc/+/e629194c62a9a129ce378e08cb1059a8a53f1795",
        "CVE ID": "CVE-2016-3741",
        "CVE Details": "The H.264 decoder in mediaserver in Android 6.x before 2016-07-01 does not initialize certain slice data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165661.",
        "CWE ID": "CWE-20",
        "commit_message": "Decoder: Initialize slice parameters before concealing error MBs\n\nAlso memset ps_dec_op structure to zero.\nFor error input, this ensures dimensions are initialized to zero\n\nBug: 28165661\nChange-Id: I66eb2ddc5e02e74b7ff04da5f749443920f37141\n",
        "fixed_function": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n \n     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n    }\n\n     ps_dec->pv_dec_out = ps_dec_op;\n     if(ps_dec->init_done != 1)\n     {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n {\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n            ps_dec->u1_top_bottom_decoded = 0;\n }\n }\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n {\n return IV_FAIL;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n if(ret != 0)\n {\n return IV_FAIL;\n }\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n",
        "vul_function": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n \n     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n     ps_dec->pv_dec_out = ps_dec_op;\n     if(ps_dec->init_done != 1)\n     {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n {\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n            ps_dec->u1_top_bottom_decoded = 0;\n }\n }\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n {\n return IV_FAIL;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n if(ret != 0)\n {\n return IV_FAIL;\n }\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3386",
            "BERTScore Recall": "0.2461",
            "BERTScore F1": "0.2850"
        },
        "llama3.1 Cosine_Similarity": 0.03602224588394165,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.03602224588394165,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3386",
            "BERTScore Recall": "0.2461",
            "BERTScore F1": "0.2850"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://android.googlesource.com/platform/external/libvpx/+/cc274e2abe8b2a6698a5c47d8aa4bb45f1f9538d",
        "CVE ID": "CVE-2016-2464",
        "CVE Details": "libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726.",
        "CWE ID": "CWE-20",
        "commit_message": "external/libvpx/libwebm: Update snapshot\n\nUpdate libwebm snapshot. This update contains security fixes from upstream.\n\nUpstream git hash: 229f49347d19b0ca0941e072b199a242ef6c5f2b\n\nBUG=23167726\n\nChange-Id: Id3e140e7b31ae11294724b1ecfe2e9c83b4d4207\n(cherry picked from commit d0281a15b3c6bd91756e453cc9398c5ef412d99a)\n",
        "fixed_function": "long Tracks::ParseTrackEntry(long long track_start, long long track_size,\n long long element_start, long long element_size,\n Track*& pResult) const {\n if (pResult)\n return -1;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = track_start;\n const long long track_stop = track_start + track_size;\n\n Track::Info info;\n\n  info.type = 0;\n  info.number = 0;\n  info.uid = 0;\n  info.defaultDuration = 0;\n\n Track::Settings v;\n  v.start = -1;\n  v.size = -1;\n\n Track::Settings a;\n  a.start = -1;\n  a.size = -1;\n\n Track::Settings e; // content_encodings_settings;\n  e.start = -1;\n  e.size = -1;\n\n long long lacing = 1; // default is true\n\n while (pos < track_stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, track_stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (size < 0)\n return E_FILE_FORMAT_INVALID;\n\n const long long start = pos;\n\n if (id == 0x60) { // VideoSettings ID\n      v.start = start;\n      v.size = size;\n } else if (id == 0x61) { // AudioSettings ID\n      a.start = start;\n      a.size = size;\n } else if (id == 0x2D80) { // ContentEncodings ID\n      e.start = start;\n      e.size = size;\n } else if (id == 0x33C5) { // Track UID\n if (size > 8)\n return E_FILE_FORMAT_INVALID;\n\n      info.uid = 0;\n\n long long pos_ = start;\n const long long pos_end = start + size;\n\n while (pos_ != pos_end) {\n unsigned char b;\n\n const int status = pReader->Read(pos_, 1, &b);\n\n if (status)\n return status;\n\n        info.uid <<= 8;\n        info.uid |= b;\n\n ++pos_;\n }\n } else if (id == 0x57) { // Track Number\n const long long num = UnserializeUInt(pReader, pos, size);\n\n if ((num <= 0) || (num > 127))\n return E_FILE_FORMAT_INVALID;\n\n      info.number = static_cast<long>(num);\n } else if (id == 0x03) { // Track Type\n const long long type = UnserializeUInt(pReader, pos, size);\n\n if ((type <= 0) || (type > 254))\n return E_FILE_FORMAT_INVALID;\n\n      info.type = static_cast<long>(type);\n } else if (id == 0x136E) { // Track Name\n const long status =\n UnserializeString(pReader, pos, size, info.nameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x02B59C) { // Track Language\n const long status = UnserializeString(pReader, pos, size, info.language);\n\n if (status)\n return status;\n } else if (id == 0x03E383) { // Default Duration\n const long long duration = UnserializeUInt(pReader, pos, size);\n\n if (duration < 0)\n return E_FILE_FORMAT_INVALID;\n\n      info.defaultDuration = static_cast<unsigned long long>(duration);\n } else if (id == 0x06) { // CodecID\n const long status = UnserializeString(pReader, pos, size, info.codecId);\n\n if (status)\n return status;\n } else if (id == 0x1C) { // lacing\n      lacing = UnserializeUInt(pReader, pos, size);\n\n if ((lacing < 0) || (lacing > 1))\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x23A2) { // Codec Private\n delete[] info.codecPrivate;\n      info.codecPrivate = NULL;\n      info.codecPrivateSize = 0;\n\n\n       const size_t buflen = static_cast<size_t>(size);\n \n       if (buflen) {\n        unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);\n \n         if (buf == NULL)\n           return -1;\n\n const int status = pReader->Read(pos, static_cast<long>(buflen), buf);\n\n if (status) {\n delete[] buf;\n return status;\n }\n\n        info.codecPrivate = buf;\n        info.codecPrivateSize = buflen;\n }\n } else if (id == 0x058688) { // Codec Name\n const long status =\n UnserializeString(pReader, pos, size, info.codecNameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x16AA) { // Codec Delay\n      info.codecDelay = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x16BB) { // Seek Pre Roll\n      info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n\n     }\n \n     pos += size;  // consume payload\n    if (pos > track_stop)\n      return E_FILE_FORMAT_INVALID;\n   }\n \n  if (pos != track_stop)\n    return E_FILE_FORMAT_INVALID;\n \n   if (info.number <= 0)  // not specified\n     return E_FILE_FORMAT_INVALID;\n\n if (GetTrackByNumber(info.number))\n return E_FILE_FORMAT_INVALID;\n\n if (info.type <= 0) // not specified\n return E_FILE_FORMAT_INVALID;\n\n  info.lacing = (lacing > 0) ? true : false;\n\n if (info.type == Track::kVideo) {\n if (v.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = v;\n\n VideoTrack* pTrack = NULL;\n\n const long status = VideoTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else if (info.type == Track::kAudio) {\n if (a.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = a;\n\n AudioTrack* pTrack = NULL;\n\n const long status = AudioTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else {\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (info.type == Track::kMetadata && e.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings.start = -1;\n    info.settings.size = 0;\n\n Track* pTrack = NULL;\n\n const long status =\n Track::Create(m_pSegment, info, element_start, element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n }\n\n return 0; // success\n}\n",
        "vul_function": "long Tracks::ParseTrackEntry(long long track_start, long long track_size,\n long long element_start, long long element_size,\n Track*& pResult) const {\n if (pResult)\n return -1;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = track_start;\n const long long track_stop = track_start + track_size;\n\n Track::Info info;\n\n  info.type = 0;\n  info.number = 0;\n  info.uid = 0;\n  info.defaultDuration = 0;\n\n Track::Settings v;\n  v.start = -1;\n  v.size = -1;\n\n Track::Settings a;\n  a.start = -1;\n  a.size = -1;\n\n Track::Settings e; // content_encodings_settings;\n  e.start = -1;\n  e.size = -1;\n\n long long lacing = 1; // default is true\n\n while (pos < track_stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, track_stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (size < 0)\n return E_FILE_FORMAT_INVALID;\n\n const long long start = pos;\n\n if (id == 0x60) { // VideoSettings ID\n      v.start = start;\n      v.size = size;\n } else if (id == 0x61) { // AudioSettings ID\n      a.start = start;\n      a.size = size;\n } else if (id == 0x2D80) { // ContentEncodings ID\n      e.start = start;\n      e.size = size;\n } else if (id == 0x33C5) { // Track UID\n if (size > 8)\n return E_FILE_FORMAT_INVALID;\n\n      info.uid = 0;\n\n long long pos_ = start;\n const long long pos_end = start + size;\n\n while (pos_ != pos_end) {\n unsigned char b;\n\n const int status = pReader->Read(pos_, 1, &b);\n\n if (status)\n return status;\n\n        info.uid <<= 8;\n        info.uid |= b;\n\n ++pos_;\n }\n } else if (id == 0x57) { // Track Number\n const long long num = UnserializeUInt(pReader, pos, size);\n\n if ((num <= 0) || (num > 127))\n return E_FILE_FORMAT_INVALID;\n\n      info.number = static_cast<long>(num);\n } else if (id == 0x03) { // Track Type\n const long long type = UnserializeUInt(pReader, pos, size);\n\n if ((type <= 0) || (type > 254))\n return E_FILE_FORMAT_INVALID;\n\n      info.type = static_cast<long>(type);\n } else if (id == 0x136E) { // Track Name\n const long status =\n UnserializeString(pReader, pos, size, info.nameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x02B59C) { // Track Language\n const long status = UnserializeString(pReader, pos, size, info.language);\n\n if (status)\n return status;\n } else if (id == 0x03E383) { // Default Duration\n const long long duration = UnserializeUInt(pReader, pos, size);\n\n if (duration < 0)\n return E_FILE_FORMAT_INVALID;\n\n      info.defaultDuration = static_cast<unsigned long long>(duration);\n } else if (id == 0x06) { // CodecID\n const long status = UnserializeString(pReader, pos, size, info.codecId);\n\n if (status)\n return status;\n } else if (id == 0x1C) { // lacing\n      lacing = UnserializeUInt(pReader, pos, size);\n\n if ((lacing < 0) || (lacing > 1))\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x23A2) { // Codec Private\n delete[] info.codecPrivate;\n      info.codecPrivate = NULL;\n      info.codecPrivateSize = 0;\n\n\n       const size_t buflen = static_cast<size_t>(size);\n \n       if (buflen) {\n        typedef unsigned char* buf_t;\n        const buf_t buf = new (std::nothrow) unsigned char[buflen];\n \n         if (buf == NULL)\n           return -1;\n\n const int status = pReader->Read(pos, static_cast<long>(buflen), buf);\n\n if (status) {\n delete[] buf;\n return status;\n }\n\n        info.codecPrivate = buf;\n        info.codecPrivateSize = buflen;\n }\n } else if (id == 0x058688) { // Codec Name\n const long status =\n UnserializeString(pReader, pos, size, info.codecNameAsUTF8);\n\n if (status)\n return status;\n } else if (id == 0x16AA) { // Codec Delay\n      info.codecDelay = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x16BB) { // Seek Pre Roll\n      info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= track_stop);\n   }\n \n  assert(pos == track_stop);\n \n   if (info.number <= 0)  // not specified\n     return E_FILE_FORMAT_INVALID;\n\n if (GetTrackByNumber(info.number))\n return E_FILE_FORMAT_INVALID;\n\n if (info.type <= 0) // not specified\n return E_FILE_FORMAT_INVALID;\n\n  info.lacing = (lacing > 0) ? true : false;\n\n if (info.type == Track::kVideo) {\n if (v.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = v;\n\n VideoTrack* pTrack = NULL;\n\n const long status = VideoTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else if (info.type == Track::kAudio) {\n if (a.start < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings = a;\n\n AudioTrack* pTrack = NULL;\n\n const long status = AudioTrack::Parse(m_pSegment, info, element_start,\n                                          element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n\n if (e.start >= 0)\n      pResult->ParseContentEncodingsEntry(e.start, e.size);\n } else {\n\n if (a.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (v.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n if (info.type == Track::kMetadata && e.start >= 0)\n return E_FILE_FORMAT_INVALID;\n\n    info.settings.start = -1;\n    info.settings.size = 0;\n\n Track* pTrack = NULL;\n\n const long status =\n Track::Create(m_pSegment, info, element_start, element_size, pTrack);\n\n if (status)\n return status;\n\n    pResult = pTrack;\n    assert(pResult);\n }\n\n return 0; // success\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3272",
            "BERTScore Recall": "0.2120",
            "BERTScore F1": "0.2573"
        },
        "llama3.1 Cosine_Similarity": 0.017348110675811768,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.017348110675811768,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3272",
            "BERTScore Recall": "0.2120",
            "BERTScore F1": "0.2573"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://android.googlesource.com/platform/external/libvpx/+/cc274e2abe8b2a6698a5c47d8aa4bb45f1f9538d",
        "CVE ID": "CVE-2016-2464",
        "CVE Details": "libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726.",
        "CWE ID": "CWE-20",
        "commit_message": "external/libvpx/libwebm: Update snapshot\n\nUpdate libwebm snapshot. This update contains security fixes from upstream.\n\nUpstream git hash: 229f49347d19b0ca0941e072b199a242ef6c5f2b\n\nBUG=23167726\n\nChange-Id: Id3e140e7b31ae11294724b1ecfe2e9c83b4d4207\n(cherry picked from commit d0281a15b3c6bd91756e453cc9398c5ef412d99a)\n",
        "fixed_function": "long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,\nlong UnserializeString(IMkvReader* pReader, long long pos, long long size,\n                       char*& str) {\n   delete[] str;\n   str = NULL;\n \n  if (size >= LONG_MAX || size < 0)\n     return E_FILE_FORMAT_INVALID;\n \n  // +1 for '\\0' terminator\n  const long required_size = static_cast<long>(size) + 1;\n \n  str = SafeArrayAlloc<char>(1, required_size);\n   if (str == NULL)\n    return E_FILE_FORMAT_INVALID;\n \n   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n const long status = pReader->Read(pos, size, buf);\n\n if (status) {\n delete[] str;\n    str = NULL;\n\n\n     return status;\n   }\n \n  str[required_size - 1] = '\\0';\n  return 0;\n }\n",
        "vul_function": "long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,\n                                  long long size_, char*& str) {\n   delete[] str;\n   str = NULL;\n \n  if (size_ >= LONG_MAX)  // we need (size+1) chars\n     return E_FILE_FORMAT_INVALID;\n \n  const long size = static_cast<long>(size_);\n \n  str = new (std::nothrow) char[size + 1];\n   if (str == NULL)\n    return -1;\n \n   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n const long status = pReader->Read(pos, size, buf);\n\n if (status) {\n delete[] str;\n    str = NULL;\n\n\n     return status;\n   }\n \n  str[size] = '\\0';\n  return 0;  // success\n }\n",
        "llama3.1 Summary": "The patch changes the calculation of the required size for the string buffer by adding 1 to the size variable, which fixes a vulnerability that allowed an attacker to write beyond the bounds of the buffer. This was done to prevent an out-of-bounds read and write issue when deserializing strings from the file. Fixed version of function: long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,\nlong UnserializeString(IMkvReader* pReader, long long pos, long long size,\n                       char*& str) {\n   delete[] str;\n   str = NULL;\n \n  if (size >= LONG_MAX || size < 0)\n     return E_FILE_FORMAT_INVALID;\n \n  // +1 for '\\0' terminator\n  const long required_size = static_cast<long>(size) + 1;\n \n  str = SafeArrayAlloc<char>(1, required_size);\n   if (str == NULL)\n    return E_FILE_FORMAT_INVALID;\n \n   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n \n const long status = pReader->Read(pos, size, buf);\n\n if (status) {\n delete[] str;\n    str = NULL;\n\n\n     return status;\n   }\n \n  str[required_size - 1] = '\\0';\n  return 0;\n }",
        "llama3.1 CWE": "CWE-119",
        "llama3.1 CVE": "CVE-2023-12345",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3832",
            "BERTScore Recall": "0.4817",
            "BERTScore F1": "0.4269"
        },
        "llama3.1 Cosine_Similarity": 0.5012387633323669,
        "Mistral Summary": "The patch changes by adding a check for array size before allocation and ensuring there is space for the null terminator character ('\\0'). This prevents a stack-based buffer overflow vulnerability caused by reading past the end of an allocated buffer. The update was applied to fix a security issue identified in the upstream code.",
        "Mistral CWE": "CWE-178 (Stack-based Buffer Overflow)",
        "Mistral CVE": "CVE-XXXX-XXXX (Cannot assign a specific CVE ID without more context, such as the affected library or product name and version)",
        "Mistral Cosine_Similarity": 0.31428229808807373,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5587",
            "BERTScore Recall": "0.4842",
            "BERTScore F1": "0.5188"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/adca986a53b31b6da4cb22f8e755f6856daea89a",
        "CVE ID": "CVE-2017-5104",
        "CVE Details": "Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.",
        "CWE ID": "CWE-20",
        "commit_message": "Don't show current RenderWidgetHostView while interstitial is showing.\n\nAlso moves interstitial page tracking from RenderFrameHostManager to\nWebContents, since interstitial pages are not frame-specific. This was\nnecessary for subframes to detect if an interstitial page is showing.\n\nBUG=729105\nTEST=See comment 13 of bug for repro steps\nCQ_INCLUDE_TRYBOTS=master.tryserver.chromium.linux:linux_site_isolation\n\nReview-Url: https://codereview.chromium.org/2938313002\nCr-Commit-Position: refs/heads/master@{#480117}",
        "fixed_function": " InterstitialPage* WebContentsImpl::GetInterstitialPage() const {\n  return interstitial_page_;\n }\n",
        "vul_function": " InterstitialPage* WebContentsImpl::GetInterstitialPage() const {\n  return GetRenderManager()->interstitial_page();\n }\n",
        "llama3.1 Summary": "The patch removes a function call to GetRenderManager()->interstitial_page() and directly returns interstitial_page_ instead. This change was necessary because interstitial pages are not frame-specific and need to be tracked at the WebContents level. Fixed version of function:  InterstitialPage* WebContentsImpl::GetInterstitialPage() const { return interstitial_page_; }",
        "llama3.1 CWE": "CWE-345",
        "llama3.1 CVE": "CVE-2015-XXXX (Note: Since I don't have the exact CVE ID, I'll leave it blank for now)",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4311",
            "BERTScore Recall": "0.4737",
            "BERTScore F1": "0.4514"
        },
        "llama3.1 Cosine_Similarity": 0.43796902894973755,
        "Mistral Summary": "The patch changes the method of retrieving the interstitial page from using RenderManager to using local tracking within WebContents. This was done to prevent potential vulnerabilities that could arise from showing the current RenderWidgetHostView while an interstitial is active, and to enable subframes to detect if an interstitial page is present, which was necessary for proper functionality.",
        "Mistral CWE": "CWE-20 (Use of a Broken Authentication Mechanism)",
        "Mistral CVE": "CVE-XXXX-XXXX (Assuming the next available CVE number for this issue in Chromium project)",
        "Mistral Cosine_Similarity": 0.454537034034729,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5354",
            "BERTScore Recall": "0.5346",
            "BERTScore F1": "0.5350"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762",
        "CVE ID": "CVE-2017-6345",
        "CVE Details": "The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls.",
        "CWE ID": "CWE-20",
        "commit_message": "net/llc: avoid BUG_ON() in skb_orphan()\n\nIt seems nobody used LLC since linux-3.12.\n\nFortunately fuzzers like syzkaller still know how to run this code,\notherwise it would be no fun.\n\nSetting skb->sk without skb->destructor leads to all kinds of\nbugs, we now prefer to be very strict about it.\n\nIdeally here we would use skb_set_owner() but this helper does not exist yet,\nonly CAN seems to have a private helper for that.\n\nFixes: 376c7311bdb6 (\"net: add a temporary sanity check in skb_orphan()\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "fixed_function": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n \tskb->sk = sk;\n\tskb->destructor = sock_efree;\n \tllc_sap_state_process(sap, skb);\n }\n",
        "vul_function": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n \tskb->sk = sk;\n \tllc_sap_state_process(sap, skb);\n }\n",
        "llama3.1 Summary": "The patch changes the order of operations in the llc_sap_rcv function by first setting skb->sk and then setting skb->destructor, ensuring that the socket owner is properly set before releasing the skbuff. This was applied to prevent bugs caused by incorrect assignment of the skbuff's destructor. \n\nFixed version of function: static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n \tskb->sk = sk;\n\tskb->destructor = sock_efree;\n \tllc_sap_state_process(sap, skb);\n }",
        "llama3.1 CWE": "CWE-416",
        "llama3.1 CVE": "CVE-2023-XXXX",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3385",
            "BERTScore Recall": "0.5226",
            "BERTScore F1": "0.4109"
        },
        "llama3.1 Cosine_Similarity": 0.49528181552886963,
        "Mistral Summary": "The patch changes by setting skb->destructor to sock_efree before setting skb->sk, ensuring proper resource management and avoiding bugs that could arise from setting skb->sk without a destructor. This change follows best practices for Linux kernel development, emphasizing strictness in handling socket buffers (skb).",
        "Mistral CWE": "CWE-476 (Resource Management Errors)",
        "Mistral CVE": "Not provided in the commit message, as it was a fix for an internal issue and not publicly disclosed.",
        "Mistral Cosine_Similarity": 0.483362078666687,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5366",
            "BERTScore Recall": "0.5912",
            "BERTScore F1": "0.5625"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/e89cfcb9090e8c98129ae9160c513f504db74599",
        "CVE ID": "CVE-2012-5148",
        "CVE Details": "The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "Remove TabContents from TabStripModelObserver::TabDetachedAt.\n\nBUG=107201\nTEST=no visible change\n\n\nReview URL: https://chromiumcodereview.appspot.com/11293205\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@167122 0039d316-1c4b-4281-b951-d872f2087c98",
        "fixed_function": "void BrowserLauncherItemController::TabDetachedAt(TabContents* contents,\nvoid BrowserLauncherItemController::TabDetachedAt(\n    content::WebContents* contents,\n    int index) {\n   launcher_controller()->UpdateAppState(\n      contents, ChromeLauncherController::APP_STATE_REMOVED);\n }\n",
        "vul_function": "void BrowserLauncherItemController::TabDetachedAt(TabContents* contents,\n                                                  int index) {\n   launcher_controller()->UpdateAppState(\n      contents->web_contents(), ChromeLauncherController::APP_STATE_REMOVED);\n }\n",
        "llama3.1 Summary": "The patch fixes a null pointer dereference vulnerability by correctly accessing the web_contents() method of the TabContents object. This was applied to prevent crashes when handling tab detach events, as identified in bug 107201. Fixed version of function: void BrowserLauncherItemController::TabDetachedAt(content::WebContents* contents,int index) { launcher_controller()->UpdateAppState(contents, ChromeLauncherController::APP_STATE_REMOVED); } Vulnerable version of function: void BrowserLauncherItemController::TabDetachedAt(TabContents* contents,int index) { launcher_controller()->UpdateAppState(contents->web_contents(), ChromeLauncherController::APP_STATE_REMOVED); }",
        "llama3.1 CWE": "CWE-758",
        "llama3.1 CVE": "CVE-2013-0876",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3496",
            "BERTScore Recall": "0.5389",
            "BERTScore F1": "0.4241"
        },
        "llama3.1 Cosine_Similarity": 0.4074958562850952,
        "Mistral Summary": "The patch changes the parameter passed to UpdateAppState function from `contents->web_contents()` to `contents`. This prevents a double free vulnerability caused by passing the same object twice. The change is related to removing TabContents from TabStripModelObserver::TabDetachedAt, which reduces memory leaks and improves overall system stability.",
        "Mistral CWE": "CWE-20",
        "Mistral CVE": "CVE-2021-XXXX-XXXX",
        "Mistral Cosine_Similarity": 0.34498393535614014,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.4838",
            "BERTScore Recall": "0.5421",
            "BERTScore F1": "0.5113"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/OP-TEE/optee_os/commit/95f36d661f2b75887772ea28baaad904bde96970",
        "CVE ID": "CVE-2019-1010293",
        "CVE Details": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Boundary crossing. The impact is: Memory corruption of the TEE itself. The component is: optee_os. The fixed version is: 3.4.0 and later.",
        "CWE ID": "CWE-20",
        "commit_message": "core: tee_mmu_check_access_rights() check all pages\n\nPrior to this patch tee_mmu_check_access_rights() checks an address in\neach page of a supplied range. If both the start and length of that\nrange is unaligned the last page in the range is sometimes not checked.\nWith this patch the first address of each page in the range is checked\nto simplify the logic of checking each page and the range and also to\ncover the last page under all circumstances.\n\nFixes: OP-TEE-2018-0005: \"tee_mmu_check_access_rights does not check\nfinal page of TA buffer\"\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
        "fixed_function": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n\tuaddr_t end_addr = 0;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n",
        "vul_function": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n",
        "llama3.1 Summary": "The patch simplifies the logic of checking each page in a supplied range by checking the first address of each page instead of the last. This ensures that all pages, including the last one, are checked under all circumstances to prevent potential memory access vulnerabilities. Fixed version of function: TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n\tuaddr_t end_addr = 0;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
        "llama3.1 CWE": "CWE-760",
        "llama3.1 CVE": "CVE-2018-XXXXX",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3426",
            "BERTScore Recall": "0.4436",
            "BERTScore F1": "0.3866"
        },
        "llama3.1 Cosine_Similarity": 0.40308618545532227,
        "Mistral Summary": "The patch changes the loop structure in the function to ensure that each page in the supplied range is checked, and that the last page is always covered. This addresses the issue of an unchecked final page in certain cases of unaligned ranges, improving the function's logic and consistency.",
        "Mistral CWE": "CWE-190 (Integer Overflow or Wraparound)",
        "Mistral CVE": "CVE-2023-XXXX-XXXX",
        "Mistral Cosine_Similarity": 0.14785706996917725,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.4988",
            "BERTScore Recall": "0.4379",
            "BERTScore F1": "0.4664"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/apache/httpd/commit/29c63b786ae028d82405421585e91283c8fa0da3",
        "CVE ID": "CVE-2016-8740",
        "CVE Details": "The mod_http2 module in the Apache HTTP Server 2.4.17 through 2.4.23, when the Protocols configuration includes h2 or h2c, does not restrict request-header length, which allows remote attackers to cause a denial of service (memory consumption) via crafted CONTINUATION frames in an HTTP/2 request.",
        "CWE ID": "CWE-20",
        "commit_message": "SECURITY: CVE-2016-8740\n\nmod_http2: properly crafted, endless HTTP/2 CONTINUATION frames could be used to exhaust all server's memory.\n\nReported by: Naveen Tiwari <naveen.tiwari@asu.edu> and CDF/SEFCOM at Arizona State University\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1772576 13f79535-47bb-0310-9956-ffa450edef68",
        "fixed_function": "apr_status_t h2_stream_add_header(h2_stream *stream,\n                                   const char *name, size_t nlen,\n                                   const char *value, size_t vlen)\n {\n    int error = 0;\n     ap_assert(stream);\n     \n    if (stream->has_response) {\n        return APR_EINVAL;    \n    }\n    ++stream->request_headers_added;\n    if (name[0] == ':') {\n        if ((vlen) > stream->session->s->limit_req_line) {\n            /* pseudo header: approximation of request line size check */\n             ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                          \"h2_stream(%ld-%d): pseudo header %s too long\", \n                           stream->session->id, stream->id, name);\n            error = HTTP_REQUEST_URI_TOO_LARGE;\n         }\n    }\n    else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n        /* header too long */\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): header %s too long\", \n                      stream->session->id, stream->id, name);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    \n    if (stream->request_headers_added \n        > stream->session->s->limit_req_fields + 4) {\n        /* too many header lines, include 4 pseudo headers */\n        if (stream->request_headers_added \n            > stream->session->s->limit_req_fields + 4 + 100) {\n            /* yeah, right */\n            return APR_ECONNRESET;\n         }\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): too many header lines\", \n                      stream->session->id, stream->id);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n     }\n     \n     if (h2_stream_is_scheduled(stream)) {\n         return add_trailer(stream, name, nlen, value, vlen);\n     }\n    else if (error) {\n        return h2_stream_set_error(stream, error); \n    }\n     else {\n         if (!stream->rtmp) {\n             stream->rtmp = h2_req_create(stream->id, stream->pool, \n                                         NULL, NULL, NULL, NULL, NULL, 0);\n        }\n        if (stream->state != H2_STREAM_ST_OPEN) {\n            return APR_ECONNRESET;\n        }\n        return h2_request_add_header(stream->rtmp, stream->pool,\n                                     name, nlen, value, vlen);\n    }\n}\n",
        "vul_function": "apr_status_t h2_stream_add_header(h2_stream *stream,\n                                   const char *name, size_t nlen,\n                                   const char *value, size_t vlen)\n {\n     ap_assert(stream);\n     \n    if (!stream->has_response) {\n        if (name[0] == ':') {\n            if ((vlen) > stream->session->s->limit_req_line) {\n                /* pseudo header: approximation of request line size check */\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): pseudo header %s too long\", \n                              stream->session->id, stream->id, name);\n                return h2_stream_set_error(stream, \n                                           HTTP_REQUEST_URI_TOO_LARGE);\n            }\n        }\n        else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n            /* header too long */\n             ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                          \"h2_stream(%ld-%d): header %s too long\", \n                           stream->session->id, stream->id, name);\n            return h2_stream_set_error(stream, \n                                       HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n         }\n        if (name[0] != ':') {\n            ++stream->request_headers_added;\n            if (stream->request_headers_added \n                > stream->session->s->limit_req_fields) {\n                /* too many header lines */\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): too many header lines\", \n                              stream->session->id, stream->id);\n                return h2_stream_set_error(stream, \n                                           HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n            }\n         }\n     }\n     \n     if (h2_stream_is_scheduled(stream)) {\n         return add_trailer(stream, name, nlen, value, vlen);\n     }\n     else {\n         if (!stream->rtmp) {\n             stream->rtmp = h2_req_create(stream->id, stream->pool, \n                                         NULL, NULL, NULL, NULL, NULL, 0);\n        }\n        if (stream->state != H2_STREAM_ST_OPEN) {\n            return APR_ECONNRESET;\n        }\n        return h2_request_add_header(stream->rtmp, stream->pool,\n                                     name, nlen, value, vlen);\n    }\n}\n",
        "llama3.1 Summary": "The patch changes the logic for handling pseudo headers and header lengths to prevent a denial of service vulnerability, where an attacker could send endless HTTP/2 CONTINUATION frames to exhaust all server memory. This was fixed by adding checks for header lengths and limits on the number of headers allowed.",
        "llama3.1 CWE": "CWE-22",
        "llama3.1 CVE": "CVE-2016-8740",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.6619",
            "BERTScore Recall": "0.6095",
            "BERTScore F1": "0.6346"
        },
        "llama3.1 Cosine_Similarity": 0.5786920785903931,
        "Mistral Summary": "The patch changes the order of header processing to check if the stream has a response before incrementing the request headers count. This prevents an attacker from exploiting endless HTTP/2 CONTINUATION frames to exhaust server memory.",
        "Mistral CWE": "CWE-319",
        "Mistral CVE": "CVE-2016-8740",
        "Mistral Cosine_Similarity": 0.5273164510726929,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.6912",
            "BERTScore Recall": "0.6026",
            "BERTScore F1": "0.6438"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b",
        "CVE ID": "CVE-2017-7539",
        "CVE Details": "An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.",
        "CWE ID": "CWE-20",
        "commit_message": "None",
        "fixed_function": "static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n",
        "vul_function": "static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n    assert(qemu_in_coroutine());\n    /* Negotiation are always in main loop. */\n    watch = qio_channel_add_watch(ioc,\n                                  G_IO_IN,\n                                  nbd_negotiate_continue,\n                                  qemu_coroutine_self(),\n                                  NULL);\n    ret = nbd_read(ioc, buffer, size, NULL);\n    g_source_remove(watch);\n    return ret;\n}\n",
        "llama3.1 Summary": "The patch removes the potential race condition by removing the use of qio_channel_add_watch and instead simply calls nbd_read directly. This change prevents a potential deadlock where the coroutine may block indefinitely waiting for the read to complete.\n Fixed version of function: static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n Vulnerable version of function: \n static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n    assert(qemu_in_coroutine());\n    /* Negotiation are always in main loop. */\n    if (!qemu_in_main_loop()) {\n        return -EPIPE;\n    }\n    ret = nbd_read(ioc, buffer, size, NULL);\n    return ret;\n}",
        "llama3.1 CWE": "CWE-22",
        "llama3.1 CVE": "CVE-2023-1234-5678",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4356",
            "BERTScore Recall": "0.5466",
            "BERTScore F1": "0.4848"
        },
        "llama3.1 Cosine_Similarity": 0.6510144472122192,
        "Mistral Summary": "The patch removes the direct data read operation (nbd_read) from the negotiate loop, reducing the risk of data exposure due to potential authentication issues. By separating the negotiation and data transfer operations, the vulnerability of using broken or erroneous authentication mechanisms in data transfer is mitigated.",
        "Mistral CWE": "CWE-125 (Use of Broken or Erroneous Authentication Mechanism)",
        "Mistral CVE": "Not provided as it should be assigned by a vulnerability tracking system.",
        "Mistral Cosine_Similarity": 0.435350239276886,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5618",
            "BERTScore Recall": "0.5368",
            "BERTScore F1": "0.5490"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://android.googlesource.com/platform/frameworks/av/+/8e438e153f661e9df8db0ac41d587e940352df06",
        "CVE ID": "CVE-2016-3830",
        "CVE Details": "codecs/aacdec/SoftAAC2.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows remote attackers to cause a denial of service (device hang or reboot) via crafted ADTS data, aka internal bug 29153599.",
        "CWE ID": "CWE-20",
        "commit_message": "SoftAAC2: fix crash on all-zero adts buffer\n\nBug: 29153599\nChange-Id: I1cb81c054098b86cf24f024f8479909ca7bc85a6\n",
        "fixed_function": "void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n    UCHAR* inBuffer[FILEREAD_MAX_LAYERS];\n    UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};\n    UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {\n if (!inQueue.empty()) {\n            INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n BufferInfo *inInfo = *inQueue.begin();\n            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n            mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;\n\n if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {\n                ALOGE(\"first buffer should have OMX_BUFFERFLAG_CODECCONFIG set\");\n                inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;\n }\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {\n BufferInfo *inInfo = *inQueue.begin();\n                OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_ConfigRaw(mAACDecoder,\n                                         inBuffer,\n                                         inBufferLength);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_ConfigRaw decoderErr = 0x%4.4x\", decoderErr);\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n                mInputBufferCount++;\n                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned\n\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n\n                configureDownmix();\n if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {\n                    ALOGI(\"Initially configuring decoder: %d Hz, %d channels\",\n                        mStreamInfo->sampleRate,\n                        mStreamInfo->numChannels);\n\n                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                    mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n return;\n }\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n continue;\n }\n\n if (mIsADTS) {\n size_t adtsHeaderSize = 0;\n\n const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;\n\n bool signalError = false;\n if (inHeader->nFilledLen < 7) {\n                    ALOGE(\"Audio data too short to contain even the ADTS header. \"\n \"Got %d bytes.\", inHeader->nFilledLen);\n                    hexdump(adtsHeader, inHeader->nFilledLen);\n                    signalError = true;\n } else {\n bool protectionAbsent = (adtsHeader[1] & 1);\n\n unsigned aac_frame_length =\n ((adtsHeader[3] & 3) << 11)\n | (adtsHeader[4] << 3)\n | (adtsHeader[5] >> 5);\n\n if (inHeader->nFilledLen < aac_frame_length) {\n                        ALOGE(\"Not enough audio data for the complete frame. \"\n \"Got %d bytes, frame size according to the ADTS \"\n \"header is %u bytes.\",\n                                inHeader->nFilledLen, aac_frame_length);\n                        hexdump(adtsHeader, inHeader->nFilledLen);\n\n                         signalError = true;\n                     } else {\n                         adtsHeaderSize = (protectionAbsent ? 7 : 9);\n                        if (aac_frame_length < adtsHeaderSize) {\n                            signalError = true;\n                        } else {\n                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;\n                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;\n \n                            inHeader->nOffset += adtsHeaderSize;\n                            inHeader->nFilledLen -= adtsHeaderSize;\n                        }\n                     }\n                 }\n \n if (signalError) {\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);\n return;\n }\n\n                mBufferSizes.add(inBufferLength[0]);\n if (mLastInHeader != inHeader) {\n                    mBufferTimestamps.add(inHeader->nTimeStamp);\n                    mLastInHeader = inHeader;\n } else {\n int64_t currentTime = mBufferTimestamps.top();\n                    currentTime += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                    mBufferTimestamps.add(currentTime);\n }\n } else {\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n                mLastInHeader = inHeader;\n                mBufferTimestamps.add(inHeader->nTimeStamp);\n                mBufferSizes.add(inHeader->nFilledLen);\n }\n\n            bytesValid[0] = inBufferLength[0];\n\n            INT prevSampleRate = mStreamInfo->sampleRate;\n            INT prevNumChannels = mStreamInfo->numChannels;\n\n            aacDecoder_Fill(mAACDecoder,\n                            inBuffer,\n                            inBufferLength,\n                            bytesValid);\n\n            mDrcWrap.submitStreamData(mStreamInfo);\n            mDrcWrap.update();\n\n            UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];\n            inHeader->nFilledLen -= inBufferUsedLength;\n            inHeader->nOffset += inBufferUsedLength;\n\n            AAC_DECODER_ERROR decoderErr;\n int numLoops = 0;\n do {\n if (outputDelayRingBufferSpaceLeft() <\n (mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                    ALOGV(\"skipping decode: not enough space left in ringbuffer\");\n break;\n }\n\n int numConsumed = mStreamInfo->numTotalBytes;\n                decoderErr = aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n 0 /* flags */);\n\n                numConsumed = mStreamInfo->numTotalBytes - numConsumed;\n                numLoops++;\n\n if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {\n break;\n }\n                mDecodedSizes.add(numConsumed);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n if (bytesValid[0] != 0) {\n                    ALOGE(\"bytesValid[0] != 0 should never happen\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n size_t numOutBytes =\n                    mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;\n\n if (decoderErr == AAC_DEC_OK) {\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n } else {\n                    ALOGW(\"AAC decoder returned error 0x%4.4x, substituting silence\", decoderErr);\n\n                    memset(tmpOutBuffer, 0, numOutBytes); // TODO: check for overflow\n\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n if (inHeader) {\n                        inHeader->nFilledLen = 0;\n }\n\n                    aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);\n\n                    mBufferSizes.pop();\n int n = 0;\n for (int i = 0; i < numLoops; i++) {\n                        n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);\n }\n                    mBufferSizes.add(n);\n\n }\n\n /*\n                 * AAC+/eAAC+ streams can be signalled in two ways: either explicitly\n                 * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual\n                 * rate system and the sampling rate in the final output is actually\n                 * doubled compared with the core AAC decoder sampling rate.\n                 *\n                 * Explicit signalling is done by explicitly defining SBR audio object\n                 * type in the bitstream. Implicit signalling is done by embedding\n                 * SBR content in AAC extension payload specific to SBR, and hence\n                 * requires an AAC decoder to perform pre-checks on actual audio frames.\n                 *\n                 * Thus, we could not say for sure whether a stream is\n                 * AAC+/eAAC+ until the first data frame is decoded.\n                 */\n if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1\n if (mStreamInfo->sampleRate != prevSampleRate ||\n                        mStreamInfo->numChannels != prevNumChannels) {\n                        ALOGI(\"Reconfiguring decoder: %d->%d Hz, %d->%d channels\",\n                              prevSampleRate, mStreamInfo->sampleRate,\n                              prevNumChannels, mStreamInfo->numChannels);\n\n                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                        mOutputPortSettingsChange = AWAITING_DISABLED;\n\n if (inHeader && inHeader->nFilledLen == 0) {\n                            inInfo->mOwnedByUs = false;\n                            mInputBufferCount++;\n                            inQueue.erase(inQueue.begin());\n                            mLastInHeader = NULL;\n                            inInfo = NULL;\n                            notifyEmptyBufferDone(inHeader);\n                            inHeader = NULL;\n }\n return;\n }\n } else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {\n                    ALOGW(\"Invalid AAC stream\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n if (inHeader && inHeader->nFilledLen == 0) {\n                    inInfo->mOwnedByUs = false;\n                    mInputBufferCount++;\n                    inQueue.erase(inQueue.begin());\n                    mLastInHeader = NULL;\n                    inInfo = NULL;\n                    notifyEmptyBufferDone(inHeader);\n                    inHeader = NULL;\n } else {\n                    ALOGV(\"inHeader->nFilledLen = %d\", inHeader ? inHeader->nFilledLen : 0);\n }\n } while (decoderErr == AAC_DEC_OK);\n }\n\n int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;\n\n if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {\n int32_t toCompensate = outputDelay - mOutputDelayCompensated;\n int32_t discard = outputDelayRingBufferSamplesAvailable();\n if (discard > toCompensate) {\n                discard = toCompensate;\n }\n int32_t discarded = outputDelayRingBufferGetSamples(0, discard);\n            mOutputDelayCompensated += discarded;\n continue;\n }\n\n if (mEndOfInput) {\n while (mOutputDelayCompensated > 0) {\n                INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n \n                 mDrcWrap.submitStreamData(mStreamInfo);\n                 mDrcWrap.update();\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n                                           AACDEC_FLUSH);\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;\n if (tmpOutBufferSamples > mOutputDelayCompensated) {\n                    tmpOutBufferSamples = mOutputDelayCompensated;\n }\n                outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);\n                mOutputDelayCompensated -= tmpOutBufferSamples;\n }\n }\n\n while (!outQueue.empty()\n && outputDelayRingBufferSamplesAvailable()\n >= mStreamInfo->frameSize * mStreamInfo->numChannels) {\n BufferInfo *outInfo = *outQueue.begin();\n            OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (outHeader->nOffset != 0) {\n                ALOGE(\"outHeader->nOffset != 0 is not handled\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n            INT_PCM *outBuffer =\n reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);\n int samplesize = mStreamInfo->numChannels * sizeof(int16_t);\n if (outHeader->nOffset\n + mStreamInfo->frameSize * samplesize\n > outHeader->nAllocLen) {\n                ALOGE(\"buffer overflow\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n\n }\n\n int available = outputDelayRingBufferSamplesAvailable();\n int numSamples = outHeader->nAllocLen / sizeof(int16_t);\n if (numSamples > available) {\n                numSamples = available;\n }\n int64_t currentTime = 0;\n if (available) {\n\n int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);\n                numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);\n\n                ALOGV(\"%d samples available (%d), or %d frames\",\n                        numSamples, available, numFrames);\n int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                currentTime = *nextTimeStamp;\n int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);\n for (int i = 0; i < numFrames; i++) {\n int32_t decodedSize = mDecodedSizes.itemAt(0);\n                    mDecodedSizes.removeAt(0);\n                    ALOGV(\"decoded %d of %d\", decodedSize, *currentBufLeft);\n if (*currentBufLeft > decodedSize) {\n *currentBufLeft -= decodedSize;\n *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                        ALOGV(\"adjusted nextTimeStamp/size to %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n } else {\n if (mBufferTimestamps.size() > 0) {\n                            mBufferTimestamps.removeAt(0);\n                            nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                            mBufferSizes.removeAt(0);\n                            currentBufLeft = &mBufferSizes.editItemAt(0);\n                            ALOGV(\"moved to next time/size: %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n }\n                        numFrames = i + 1;\n                        numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;\n break;\n }\n }\n\n                ALOGV(\"getting %d from ringbuffer\", numSamples);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);\n if (ns != numSamples) {\n                    ALOGE(\"not a complete frame of samples available\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n }\n\n            outHeader->nFilledLen = numSamples * sizeof(int16_t);\n\n if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mEndOfOutput = true;\n } else {\n                outHeader->nFlags = 0;\n }\n\n            outHeader->nTimeStamp = currentTime;\n\n            mOutputBufferCount++;\n            outInfo->mOwnedByUs = false;\n            outQueue.erase(outQueue.begin());\n            outInfo = NULL;\n            ALOGV(\"out timestamp %lld / %d\", outHeader->nTimeStamp, outHeader->nFilledLen);\n            notifyFillBufferDone(outHeader);\n            outHeader = NULL;\n }\n\n if (mEndOfInput) {\n int ringBufAvail = outputDelayRingBufferSamplesAvailable();\n if (!outQueue.empty()\n && ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {\n if (!mEndOfOutput) {\n                    mEndOfOutput = true;\n BufferInfo *outInfo = *outQueue.begin();\n                    OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n                    INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer\n + outHeader->nOffset);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);\n if (ns < 0) {\n                        ns = 0;\n }\n                    outHeader->nFilledLen = ns;\n                    outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                    outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);\n                    mBufferTimestamps.clear();\n                    mBufferSizes.clear();\n                    mDecodedSizes.clear();\n\n                    mOutputBufferCount++;\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n break; // if outQueue not empty but no more output\n }\n }\n }\n}\n",
        "vul_function": "void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n    UCHAR* inBuffer[FILEREAD_MAX_LAYERS];\n    UINT inBufferLength[FILEREAD_MAX_LAYERS] = {0};\n    UINT bytesValid[FILEREAD_MAX_LAYERS] = {0};\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || mEndOfInput) && !outQueue.empty()) {\n if (!inQueue.empty()) {\n            INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n BufferInfo *inInfo = *inQueue.begin();\n            OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n            mEndOfInput = (inHeader->nFlags & OMX_BUFFERFLAG_EOS) != 0;\n\n if (mInputBufferCount == 0 && !(inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG)) {\n                ALOGE(\"first buffer should have OMX_BUFFERFLAG_CODECCONFIG set\");\n                inHeader->nFlags |= OMX_BUFFERFLAG_CODECCONFIG;\n }\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) != 0) {\n BufferInfo *inInfo = *inQueue.begin();\n                OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_ConfigRaw(mAACDecoder,\n                                         inBuffer,\n                                         inBufferLength);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_ConfigRaw decoderErr = 0x%4.4x\", decoderErr);\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n                mInputBufferCount++;\n                mOutputBufferCount++; // fake increase of outputBufferCount to keep the counters aligned\n\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n\n                configureDownmix();\n if (mStreamInfo->sampleRate && mStreamInfo->numChannels) {\n                    ALOGI(\"Initially configuring decoder: %d Hz, %d channels\",\n                        mStreamInfo->sampleRate,\n                        mStreamInfo->numChannels);\n\n                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                    mOutputPortSettingsChange = AWAITING_DISABLED;\n }\n return;\n }\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                mLastInHeader = NULL;\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n continue;\n }\n\n if (mIsADTS) {\n size_t adtsHeaderSize = 0;\n\n const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;\n\n bool signalError = false;\n if (inHeader->nFilledLen < 7) {\n                    ALOGE(\"Audio data too short to contain even the ADTS header. \"\n \"Got %d bytes.\", inHeader->nFilledLen);\n                    hexdump(adtsHeader, inHeader->nFilledLen);\n                    signalError = true;\n } else {\n bool protectionAbsent = (adtsHeader[1] & 1);\n\n unsigned aac_frame_length =\n ((adtsHeader[3] & 3) << 11)\n | (adtsHeader[4] << 3)\n | (adtsHeader[5] >> 5);\n\n if (inHeader->nFilledLen < aac_frame_length) {\n                        ALOGE(\"Not enough audio data for the complete frame. \"\n \"Got %d bytes, frame size according to the ADTS \"\n \"header is %u bytes.\",\n                                inHeader->nFilledLen, aac_frame_length);\n                        hexdump(adtsHeader, inHeader->nFilledLen);\n\n                         signalError = true;\n                     } else {\n                         adtsHeaderSize = (protectionAbsent ? 7 : 9);\n \n                        inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;\n                        inBufferLength[0] = aac_frame_length - adtsHeaderSize;\n                        inHeader->nOffset += adtsHeaderSize;\n                        inHeader->nFilledLen -= adtsHeaderSize;\n                     }\n                 }\n \n if (signalError) {\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorStreamCorrupt, ERROR_MALFORMED, NULL);\n return;\n }\n\n                mBufferSizes.add(inBufferLength[0]);\n if (mLastInHeader != inHeader) {\n                    mBufferTimestamps.add(inHeader->nTimeStamp);\n                    mLastInHeader = inHeader;\n } else {\n int64_t currentTime = mBufferTimestamps.top();\n                    currentTime += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                    mBufferTimestamps.add(currentTime);\n }\n } else {\n                inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;\n                inBufferLength[0] = inHeader->nFilledLen;\n                mLastInHeader = inHeader;\n                mBufferTimestamps.add(inHeader->nTimeStamp);\n                mBufferSizes.add(inHeader->nFilledLen);\n }\n\n            bytesValid[0] = inBufferLength[0];\n\n            INT prevSampleRate = mStreamInfo->sampleRate;\n            INT prevNumChannels = mStreamInfo->numChannels;\n\n            aacDecoder_Fill(mAACDecoder,\n                            inBuffer,\n                            inBufferLength,\n                            bytesValid);\n\n            mDrcWrap.submitStreamData(mStreamInfo);\n            mDrcWrap.update();\n\n            UINT inBufferUsedLength = inBufferLength[0] - bytesValid[0];\n            inHeader->nFilledLen -= inBufferUsedLength;\n            inHeader->nOffset += inBufferUsedLength;\n\n            AAC_DECODER_ERROR decoderErr;\n int numLoops = 0;\n do {\n if (outputDelayRingBufferSpaceLeft() <\n (mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                    ALOGV(\"skipping decode: not enough space left in ringbuffer\");\n break;\n }\n\n int numConsumed = mStreamInfo->numTotalBytes;\n                decoderErr = aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n 0 /* flags */);\n\n                numConsumed = mStreamInfo->numTotalBytes - numConsumed;\n                numLoops++;\n\n if (decoderErr == AAC_DEC_NOT_ENOUGH_BITS) {\n break;\n }\n                mDecodedSizes.add(numConsumed);\n\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n if (bytesValid[0] != 0) {\n                    ALOGE(\"bytesValid[0] != 0 should never happen\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n size_t numOutBytes =\n                    mStreamInfo->frameSize * sizeof(int16_t) * mStreamInfo->numChannels;\n\n if (decoderErr == AAC_DEC_OK) {\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n } else {\n                    ALOGW(\"AAC decoder returned error 0x%4.4x, substituting silence\", decoderErr);\n\n                    memset(tmpOutBuffer, 0, numOutBytes); // TODO: check for overflow\n\n if (!outputDelayRingBufferPutSamples(tmpOutBuffer,\n                            mStreamInfo->frameSize * mStreamInfo->numChannels)) {\n                        mSignalledError = true;\n                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n\n if (inHeader) {\n                        inHeader->nFilledLen = 0;\n }\n\n                    aacDecoder_SetParam(mAACDecoder, AAC_TPDEC_CLEAR_BUFFER, 1);\n\n                    mBufferSizes.pop();\n int n = 0;\n for (int i = 0; i < numLoops; i++) {\n                        n += mDecodedSizes.itemAt(mDecodedSizes.size() - numLoops + i);\n }\n                    mBufferSizes.add(n);\n\n }\n\n /*\n                 * AAC+/eAAC+ streams can be signalled in two ways: either explicitly\n                 * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual\n                 * rate system and the sampling rate in the final output is actually\n                 * doubled compared with the core AAC decoder sampling rate.\n                 *\n                 * Explicit signalling is done by explicitly defining SBR audio object\n                 * type in the bitstream. Implicit signalling is done by embedding\n                 * SBR content in AAC extension payload specific to SBR, and hence\n                 * requires an AAC decoder to perform pre-checks on actual audio frames.\n                 *\n                 * Thus, we could not say for sure whether a stream is\n                 * AAC+/eAAC+ until the first data frame is decoded.\n                 */\n if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1\n if (mStreamInfo->sampleRate != prevSampleRate ||\n                        mStreamInfo->numChannels != prevNumChannels) {\n                        ALOGI(\"Reconfiguring decoder: %d->%d Hz, %d->%d channels\",\n                              prevSampleRate, mStreamInfo->sampleRate,\n                              prevNumChannels, mStreamInfo->numChannels);\n\n                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n                        mOutputPortSettingsChange = AWAITING_DISABLED;\n\n if (inHeader && inHeader->nFilledLen == 0) {\n                            inInfo->mOwnedByUs = false;\n                            mInputBufferCount++;\n                            inQueue.erase(inQueue.begin());\n                            mLastInHeader = NULL;\n                            inInfo = NULL;\n                            notifyEmptyBufferDone(inHeader);\n                            inHeader = NULL;\n }\n return;\n }\n } else if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {\n                    ALOGW(\"Invalid AAC stream\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n return;\n }\n if (inHeader && inHeader->nFilledLen == 0) {\n                    inInfo->mOwnedByUs = false;\n                    mInputBufferCount++;\n                    inQueue.erase(inQueue.begin());\n                    mLastInHeader = NULL;\n                    inInfo = NULL;\n                    notifyEmptyBufferDone(inHeader);\n                    inHeader = NULL;\n } else {\n                    ALOGV(\"inHeader->nFilledLen = %d\", inHeader ? inHeader->nFilledLen : 0);\n }\n } while (decoderErr == AAC_DEC_OK);\n }\n\n int32_t outputDelay = mStreamInfo->outputDelay * mStreamInfo->numChannels;\n\n if (!mEndOfInput && mOutputDelayCompensated < outputDelay) {\n int32_t toCompensate = outputDelay - mOutputDelayCompensated;\n int32_t discard = outputDelayRingBufferSamplesAvailable();\n if (discard > toCompensate) {\n                discard = toCompensate;\n }\n int32_t discarded = outputDelayRingBufferGetSamples(0, discard);\n            mOutputDelayCompensated += discarded;\n continue;\n }\n\n if (mEndOfInput) {\n while (mOutputDelayCompensated > 0) {\n                INT_PCM tmpOutBuffer[2048 * MAX_CHANNEL_COUNT];\n \n                 mDrcWrap.submitStreamData(mStreamInfo);\n                 mDrcWrap.update();\n\n                AAC_DECODER_ERROR decoderErr =\n                    aacDecoder_DecodeFrame(mAACDecoder,\n                                           tmpOutBuffer,\n 2048 * MAX_CHANNEL_COUNT,\n                                           AACDEC_FLUSH);\n if (decoderErr != AAC_DEC_OK) {\n                    ALOGW(\"aacDecoder_DecodeFrame decoderErr = 0x%4.4x\", decoderErr);\n }\n\n int32_t tmpOutBufferSamples = mStreamInfo->frameSize * mStreamInfo->numChannels;\n if (tmpOutBufferSamples > mOutputDelayCompensated) {\n                    tmpOutBufferSamples = mOutputDelayCompensated;\n }\n                outputDelayRingBufferPutSamples(tmpOutBuffer, tmpOutBufferSamples);\n                mOutputDelayCompensated -= tmpOutBufferSamples;\n }\n }\n\n while (!outQueue.empty()\n && outputDelayRingBufferSamplesAvailable()\n >= mStreamInfo->frameSize * mStreamInfo->numChannels) {\n BufferInfo *outInfo = *outQueue.begin();\n            OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (outHeader->nOffset != 0) {\n                ALOGE(\"outHeader->nOffset != 0 is not handled\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n\n            INT_PCM *outBuffer =\n reinterpret_cast<INT_PCM *>(outHeader->pBuffer + outHeader->nOffset);\n int samplesize = mStreamInfo->numChannels * sizeof(int16_t);\n if (outHeader->nOffset\n + mStreamInfo->frameSize * samplesize\n > outHeader->nAllocLen) {\n                ALOGE(\"buffer overflow\");\n                mSignalledError = true;\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n\n }\n\n int available = outputDelayRingBufferSamplesAvailable();\n int numSamples = outHeader->nAllocLen / sizeof(int16_t);\n if (numSamples > available) {\n                numSamples = available;\n }\n int64_t currentTime = 0;\n if (available) {\n\n int numFrames = numSamples / (mStreamInfo->frameSize * mStreamInfo->numChannels);\n                numSamples = numFrames * (mStreamInfo->frameSize * mStreamInfo->numChannels);\n\n                ALOGV(\"%d samples available (%d), or %d frames\",\n                        numSamples, available, numFrames);\n int64_t *nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                currentTime = *nextTimeStamp;\n int32_t *currentBufLeft = &mBufferSizes.editItemAt(0);\n for (int i = 0; i < numFrames; i++) {\n int32_t decodedSize = mDecodedSizes.itemAt(0);\n                    mDecodedSizes.removeAt(0);\n                    ALOGV(\"decoded %d of %d\", decodedSize, *currentBufLeft);\n if (*currentBufLeft > decodedSize) {\n *currentBufLeft -= decodedSize;\n *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *\n 1000000ll / mStreamInfo->aacSampleRate;\n                        ALOGV(\"adjusted nextTimeStamp/size to %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n } else {\n if (mBufferTimestamps.size() > 0) {\n                            mBufferTimestamps.removeAt(0);\n                            nextTimeStamp = &mBufferTimestamps.editItemAt(0);\n                            mBufferSizes.removeAt(0);\n                            currentBufLeft = &mBufferSizes.editItemAt(0);\n                            ALOGV(\"moved to next time/size: %lld/%d\",\n (long long) *nextTimeStamp, *currentBufLeft);\n }\n                        numFrames = i + 1;\n                        numSamples = numFrames * mStreamInfo->frameSize * mStreamInfo->numChannels;\n break;\n }\n }\n\n                ALOGV(\"getting %d from ringbuffer\", numSamples);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, numSamples);\n if (ns != numSamples) {\n                    ALOGE(\"not a complete frame of samples available\");\n                    mSignalledError = true;\n                    notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n return;\n }\n }\n\n            outHeader->nFilledLen = numSamples * sizeof(int16_t);\n\n if (mEndOfInput && !outQueue.empty() && outputDelayRingBufferSamplesAvailable() == 0) {\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mEndOfOutput = true;\n } else {\n                outHeader->nFlags = 0;\n }\n\n            outHeader->nTimeStamp = currentTime;\n\n            mOutputBufferCount++;\n            outInfo->mOwnedByUs = false;\n            outQueue.erase(outQueue.begin());\n            outInfo = NULL;\n            ALOGV(\"out timestamp %lld / %d\", outHeader->nTimeStamp, outHeader->nFilledLen);\n            notifyFillBufferDone(outHeader);\n            outHeader = NULL;\n }\n\n if (mEndOfInput) {\n int ringBufAvail = outputDelayRingBufferSamplesAvailable();\n if (!outQueue.empty()\n && ringBufAvail < mStreamInfo->frameSize * mStreamInfo->numChannels) {\n if (!mEndOfOutput) {\n                    mEndOfOutput = true;\n BufferInfo *outInfo = *outQueue.begin();\n                    OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n                    INT_PCM *outBuffer = reinterpret_cast<INT_PCM *>(outHeader->pBuffer\n + outHeader->nOffset);\n int32_t ns = outputDelayRingBufferGetSamples(outBuffer, ringBufAvail);\n if (ns < 0) {\n                        ns = 0;\n }\n                    outHeader->nFilledLen = ns;\n                    outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                    outHeader->nTimeStamp = mBufferTimestamps.itemAt(0);\n                    mBufferTimestamps.clear();\n                    mBufferSizes.clear();\n                    mDecodedSizes.clear();\n\n                    mOutputBufferCount++;\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n break; // if outQueue not empty but no more output\n }\n }\n }\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3157",
            "BERTScore Recall": "0.2094",
            "BERTScore F1": "0.2518"
        },
        "llama3.1 Cosine_Similarity": 0.04633831977844238,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.04633831977844238,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3157",
            "BERTScore Recall": "0.2094",
            "BERTScore F1": "0.2518"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "CVE ID": "CVE-2013-7271",
        "CVE Details": "The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",
        "CWE ID": "CWE-20",
        "commit_message": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "fixed_function": "static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size,\n\t\t\t      int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(iocb);\n\tstruct scm_cookie tmp_scm;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint err;\n\tint peeked, skip;\n\n\terr = -EOPNOTSUPP;\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n\t\tgoto out;\n\t}\n\n\tskip = sk_peek_offset(sk, flags);\n\n\tskb = __skb_recv_datagram(sk, flags, &peeked, &skip, &err);\n\tif (!skb) {\n\t\tunix_state_lock(sk);\n\t\t/* Signal EOF on disconnected non-blocking SEQPACKET socket. */\n\t\tif (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\terr = 0;\n\t\tunix_state_unlock(sk);\n\t\tgoto out_unlock;\n\t}\n\n\twake_up_interruptible_sync_poll(&u->peer_wait,\n\t\t\t\t\tPOLLOUT | POLLWRNORM | POLLWRBAND);\n\n\tif (msg->msg_name)\n\t\tunix_copy_addr(msg, skb->sk);\n\n\tif (size > skb->len - skip)\n\t\tsize = skb->len - skip;\n\telse if (size < skb->len - skip)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, skip, msg->msg_iov, size);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock_flag(sk, SOCK_RCVTSTAMP))\n\t\t__sock_recv_timestamp(msg, sk, skb);\n\n\tif (!siocb->scm) {\n\t\tsiocb->scm = &tmp_scm;\n\t\tmemset(&tmp_scm, 0, sizeof(tmp_scm));\n\t}\n\tscm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\tunix_set_secdata(siocb->scm, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tif (UNIXCB(skb).fp)\n\t\t\tunix_detach_fds(siocb->scm, skb);\n\n\t\tsk_peek_offset_bwd(sk, skb->len);\n\t} else {\n\t\t/* It is questionable: on PEEK we could:\n\t\t   - do not return fds - good, but too simple 8)\n\t\t   - return fds, and do not return them on read (old strategy,\n\t\t     apparently wrong)\n\t\t   - clone fds (I chose it for now, it is the most universal\n\t\t     solution)\n\n\t\t   POSIX 1003.1g does not actually define this clearly\n\t\t   at all. POSIX 1003.1g doesn't define a lot of things\n\t\t   clearly however!\n\n\t\t*/\n\n\t\tsk_peek_offset_fwd(sk, size);\n\n\t\tif (UNIXCB(skb).fp)\n\t\t\tsiocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);\n\t}\n\terr = (flags & MSG_TRUNC) ? skb->len - skip : size;\n\n\tscm_recv(sock, msg, siocb->scm, flags);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout_unlock:\n\tmutex_unlock(&u->readlock);\nout:\n\treturn err;\n}\n",
        "vul_function": "static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size,\n\t\t\t      int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(iocb);\n\tstruct scm_cookie tmp_scm;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint err;\n\tint peeked, skip;\n\n\terr = -EOPNOTSUPP;\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n\tmsg->msg_namelen = 0;\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n\t\tgoto out;\n\t}\n\n\tskip = sk_peek_offset(sk, flags);\n\n\tskb = __skb_recv_datagram(sk, flags, &peeked, &skip, &err);\n\tif (!skb) {\n\t\tunix_state_lock(sk);\n\t\t/* Signal EOF on disconnected non-blocking SEQPACKET socket. */\n\t\tif (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\terr = 0;\n\t\tunix_state_unlock(sk);\n\t\tgoto out_unlock;\n\t}\n\n\twake_up_interruptible_sync_poll(&u->peer_wait,\n\t\t\t\t\tPOLLOUT | POLLWRNORM | POLLWRBAND);\n\n\tif (msg->msg_name)\n\t\tunix_copy_addr(msg, skb->sk);\n\n\tif (size > skb->len - skip)\n\t\tsize = skb->len - skip;\n\telse if (size < skb->len - skip)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, skip, msg->msg_iov, size);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (sock_flag(sk, SOCK_RCVTSTAMP))\n\t\t__sock_recv_timestamp(msg, sk, skb);\n\n\tif (!siocb->scm) {\n\t\tsiocb->scm = &tmp_scm;\n\t\tmemset(&tmp_scm, 0, sizeof(tmp_scm));\n\t}\n\tscm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\tunix_set_secdata(siocb->scm, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tif (UNIXCB(skb).fp)\n\t\t\tunix_detach_fds(siocb->scm, skb);\n\n\t\tsk_peek_offset_bwd(sk, skb->len);\n\t} else {\n\t\t/* It is questionable: on PEEK we could:\n\t\t   - do not return fds - good, but too simple 8)\n\t\t   - return fds, and do not return them on read (old strategy,\n\t\t     apparently wrong)\n\t\t   - clone fds (I chose it for now, it is the most universal\n\t\t     solution)\n\n\t\t   POSIX 1003.1g does not actually define this clearly\n\t\t   at all. POSIX 1003.1g doesn't define a lot of things\n\t\t   clearly however!\n\n\t\t*/\n\n\t\tsk_peek_offset_fwd(sk, size);\n\n\t\tif (UNIXCB(skb).fp)\n\t\t\tsiocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);\n\t}\n\terr = (flags & MSG_TRUNC) ? skb->len - skip : size;\n\n\tscm_recv(sock, msg, siocb->scm, flags);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout_unlock:\n\tmutex_unlock(&u->readlock);\nout:\n\treturn err;\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3323",
            "BERTScore Recall": "0.2148",
            "BERTScore F1": "0.2609"
        },
        "llama3.1 Cosine_Similarity": 0.001175999641418457,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.001175999641418457,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3323",
            "BERTScore Recall": "0.2148",
            "BERTScore F1": "0.2609"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/c63f2b7fe4fe2977f858a8e36d5f48db17eff2e7",
        "CVE ID": "CVE-2011-2839",
        "CVE Details": "The PDF implementation in Google Chrome before 13.0.782.215 on Linux does not properly use the memset library function, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "Extend TTS extension API to support richer events returned from the engine\nto the client. Previously we just had a completed event; this adds start,\nword boundary, sentence boundary, and marker boundary. In addition,\ninterrupted and canceled, which were previously errors, now become events.\nMac and Windows implementations extended to support as many of these events\nas possible.\n\nBUG=67713\nBUG=70198\nBUG=75106\nBUG=83404\n\nTEST=Updates all TTS API tests to be event-based, and adds new tests.\nReview URL: http://codereview.chromium.org/6792014\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@91665 0039d316-1c4b-4281-b951-d872f2087c98",
        "fixed_function": "void ExtensionTtsController::ClearUtteranceQueue() {\n  std::set<std::string> required_event_types;\n  if (options->HasKey(constants::kRequiredEventTypesKey)) {\n    ListValue* list;\n    EXTENSION_FUNCTION_VALIDATE(\n        options->GetList(constants::kRequiredEventTypesKey, &list));\n    for (size_t i = 0; i < list->GetSize(); i++) {\n      std::string event_type;\n      if (!list->GetString(i, &event_type))\n        required_event_types.insert(event_type);\n    }\n   }\n",
        "vul_function": "void ExtensionTtsController::ClearUtteranceQueue() {\n  while (!utterance_queue_.empty()) {\n    Utterance* utterance = utterance_queue_.front();\n    utterance_queue_.pop();\n    utterance->set_error(kSpeechRemovedFromQueueError);\n    utterance->FinishAndDestroy();\n   }\n}\n",
        "llama3.1 Summary": "The patch changes the way utterances are handled in the ClearUtteranceQueue function, ensuring that utterances are properly removed from the queue and their errors set accordingly. This change was applied to prevent potential issues with utterance handling and to align with the updated event-based API. Fixed version of function: void ExtensionTtsController::ClearUtteranceQueue() { std::set<std::string> required_event_types; if (options->HasKey(constants::kRequiredEventTypesKey)) { ListValue* list; EXTENSION_FUNCTION_VALIDATE( options->GetList(constants::kRequiredEventTypesKey, &list)); for (size_t i = 0; i < list->GetSize(); i++) { std::string event_type; if (!list->GetString(i, &event_type)) required_event_types.insert(event_type); } } }",
        "llama3.1 CWE": "CWE-20",
        "llama3.1 CVE": "CVE-2008-3522",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3769",
            "BERTScore Recall": "0.5480",
            "BERTScore F1": "0.4466"
        },
        "llama3.1 Cosine_Similarity": 0.16204524040222168,
        "Mistral Summary": "The patch changes to extend the TTS extension API to support richer events by modifying the `ClearUtteranceQueue()` function. The previous version of the function pops and clears all utterances from the queue without any checks or filters, which could potentially expose hard-coded credentials if an utterance contains sensitive data. The new version includes a check for specific event types before processing each utterance, thus mitigating this potential vulnerability.",
        "Mistral CWE": "CWE-399 (Use of Hard-coded Credentials)",
        "Mistral CVE": "Not applicable as this is a software vulnerability, not an externally facing one.",
        "Mistral Cosine_Similarity": 0.24952900409698486,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5224",
            "BERTScore Recall": "0.5671",
            "BERTScore F1": "0.5438"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/282f53ffdc3b1902da86f6a0791af736837efbf8",
        "CVE ID": "CVE-2016-1665",
        "CVE Details": "The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code.",
        "CWE ID": "CWE-20",
        "commit_message": "[signin] Add metrics to track the source for refresh token updated events\n\nThis CL add a source for update and revoke credentials operations. It then\nsurfaces the source in the chrome://signin-internals page.\n\nThis CL also records the following histograms that track refresh token events:\n* Signin.RefreshTokenUpdated.ToValidToken.Source\n* Signin.RefreshTokenUpdated.ToInvalidToken.Source\n* Signin.RefreshTokenRevoked.Source\n\nThese histograms are needed to validate the assumptions of how often tokens\nare revoked by the browser and the sources for the token revocations.\n\nBug: 896182\n\nChange-Id: I2fcab80ee8e5699708e695bc3289fa6d34859a90\nReviewed-on: https://chromium-review.googlesource.com/c/1286464\nReviewed-by: Jochen Eisinger <jochen@chromium.org>\nReviewed-by: David Roger <droger@chromium.org>\nReviewed-by: Ilya Sherman <isherman@chromium.org>\nCommit-Queue: Mihai Sardarescu <msarda@chromium.org>\nCr-Commit-Position: refs/heads/master@{#606181}",
        "fixed_function": "void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(\n    const ClientOAuthResult& result,\n    Profile* profile,\n    Profile::CreateStatus status) {\n  if (is_force_sign_in_with_usermanager_)\n    UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());\n  Browser* browser = NULL;\n  if (handler_) {\n    browser = handler_->GetDesktopBrowser();\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  about_signin_internals->OnRefreshTokenReceived(\"Successful\");\n\n  std::string account_id =\n      AccountTrackerServiceFactory::GetForProfile(profile_)\n          ->SeedAccountInfo(gaia_id_, email_);\n\n  signin_metrics::AccessPoint access_point =\n      signin::GetAccessPointForPromoURL(current_url_);\n  signin_metrics::Reason reason =\n      signin::GetSigninReasonForPromoURL(current_url_);\n\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n  std::string primary_email =\n      signin_manager->GetAuthenticatedAccountInfo().email;\n  if (gaia::AreEmailsSame(email_, primary_email) &&\n      (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK) &&\n      !password_.empty() && profiles::IsLockAvailable(profile_)) {\n    LocalAuth::SetLocalAuthCredentials(profile_, password_);\n  }\n\n#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)\n  if (!password_.empty()) {\n    scoped_refptr<password_manager::PasswordStore> password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS);\n    if (password_store && !primary_email.empty()) {\n      password_store->SaveGaiaPasswordHash(\n          primary_email, base::UTF8ToUTF16(password_),\n          password_manager::metrics_util::SyncPasswordHashChange::\n              SAVED_ON_CHROME_SIGNIN);\n    }\n  }\n#endif\n\n   if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK ||\n       reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {\n    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)\n        ->UpdateCredentials(account_id, result.refresh_token,\n                            signin_metrics::SourceForRefreshTokenOperation::\n                                kInlineLoginHandler_Signin);\n \n     if (signin::IsAutoCloseEnabledInURL(current_url_)) {\n      bool show_account_management = ShouldShowAccountManagement(\n          current_url_,\n          AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,\n                                    show_account_management));\n    }\n\n    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n        reason == signin_metrics::Reason::REASON_UNLOCK) {\n      signin_manager->MergeSigninCredentialIntoCookieJar();\n    }\n    LogSigninReason(reason);\n  } else {\n    browser_sync::ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile_);\n    SigninErrorController* error_controller =\n        SigninErrorControllerFactory::GetForProfile(profile_);\n\n    OneClickSigninSyncStarter::StartSyncMode start_mode =\n        OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;\n    if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||\n        choose_what_to_sync_) {\n      bool show_settings_without_configure =\n          error_controller->HasError() && sync_service &&\n          sync_service->IsFirstSetupComplete();\n      if (!show_settings_without_configure)\n        start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;\n    }\n\n    OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =\n        confirm_untrusted_signin_ ?\n            OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :\n            OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;\n\n    bool start_signin = !HandleCrossAccountError(\n        result.refresh_token, confirmation_required, start_mode);\n    if (start_signin) {\n      CreateSyncStarter(browser, current_url_, result.refresh_token,\n                        OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,\n                        confirmation_required);\n      base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);\n    }\n  }\n}\n",
        "vul_function": "void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(\n    const ClientOAuthResult& result,\n    Profile* profile,\n    Profile::CreateStatus status) {\n  if (is_force_sign_in_with_usermanager_)\n    UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());\n  Browser* browser = NULL;\n  if (handler_) {\n    browser = handler_->GetDesktopBrowser();\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  about_signin_internals->OnRefreshTokenReceived(\"Successful\");\n\n  std::string account_id =\n      AccountTrackerServiceFactory::GetForProfile(profile_)\n          ->SeedAccountInfo(gaia_id_, email_);\n\n  signin_metrics::AccessPoint access_point =\n      signin::GetAccessPointForPromoURL(current_url_);\n  signin_metrics::Reason reason =\n      signin::GetSigninReasonForPromoURL(current_url_);\n\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n  std::string primary_email =\n      signin_manager->GetAuthenticatedAccountInfo().email;\n  if (gaia::AreEmailsSame(email_, primary_email) &&\n      (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK) &&\n      !password_.empty() && profiles::IsLockAvailable(profile_)) {\n    LocalAuth::SetLocalAuthCredentials(profile_, password_);\n  }\n\n#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)\n  if (!password_.empty()) {\n    scoped_refptr<password_manager::PasswordStore> password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS);\n    if (password_store && !primary_email.empty()) {\n      password_store->SaveGaiaPasswordHash(\n          primary_email, base::UTF8ToUTF16(password_),\n          password_manager::metrics_util::SyncPasswordHashChange::\n              SAVED_ON_CHROME_SIGNIN);\n    }\n  }\n#endif\n\n   if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK ||\n       reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {\n    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->\n        UpdateCredentials(account_id, result.refresh_token);\n \n     if (signin::IsAutoCloseEnabledInURL(current_url_)) {\n      bool show_account_management = ShouldShowAccountManagement(\n          current_url_,\n          AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,\n                                    show_account_management));\n    }\n\n    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n        reason == signin_metrics::Reason::REASON_UNLOCK) {\n      signin_manager->MergeSigninCredentialIntoCookieJar();\n    }\n    LogSigninReason(reason);\n  } else {\n    browser_sync::ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile_);\n    SigninErrorController* error_controller =\n        SigninErrorControllerFactory::GetForProfile(profile_);\n\n    OneClickSigninSyncStarter::StartSyncMode start_mode =\n        OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;\n    if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||\n        choose_what_to_sync_) {\n      bool show_settings_without_configure =\n          error_controller->HasError() && sync_service &&\n          sync_service->IsFirstSetupComplete();\n      if (!show_settings_without_configure)\n        start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;\n    }\n\n    OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =\n        confirm_untrusted_signin_ ?\n            OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :\n            OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;\n\n    bool start_signin = !HandleCrossAccountError(\n        result.refresh_token, confirmation_required, start_mode);\n    if (start_signin) {\n      CreateSyncStarter(browser, current_url_, result.refresh_token,\n                        OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,\n                        confirmation_required);\n      base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);\n    }\n  }\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3264",
            "BERTScore Recall": "0.2228",
            "BERTScore F1": "0.2648"
        },
        "llama3.1 Cosine_Similarity": 0.04213172197341919,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.04213172197341919,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3264",
            "BERTScore Recall": "0.2228",
            "BERTScore F1": "0.2648"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/b944f670bb7a8a919daac497a4ea0536c954c201",
        "CVE ID": "CVE-2011-2350",
        "CVE Details": "The HTML parser in Google Chrome before 12.0.742.112 does not properly address \"lifetime and re-entrancy issues,\" which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "[JSC] Implement a helper method createNotEnoughArgumentsError()\nhttps://bugs.webkit.org/show_bug.cgi?id=85102\n\nReviewed by Geoffrey Garen.\n\nIn bug 84787, kbr@ requested to avoid hard-coding\ncreateTypeError(exec, \"Not enough arguments\") here and there.\nThis patch implements createNotEnoughArgumentsError(exec)\nand uses it in JSC bindings.\n\nc.f. a corresponding bug for V8 bindings is bug 85097.\n\nSource/JavaScriptCore:\n\n* runtime/Error.cpp:\n(JSC::createNotEnoughArgumentsError):\n(JSC):\n* runtime/Error.h:\n(JSC):\n\nSource/WebCore:\n\nTest: bindings/scripts/test/TestObj.idl\n\n* bindings/scripts/CodeGeneratorJS.pm: Modified as described above.\n(GenerateArgumentsCountCheck):\n\n* bindings/js/JSDataViewCustom.cpp: Ditto.\n(WebCore::getDataViewMember):\n(WebCore::setDataViewMember):\n* bindings/js/JSDeprecatedPeerConnectionCustom.cpp:\n(WebCore::JSDeprecatedPeerConnectionConstructor::constructJSDeprecatedPeerConnection):\n* bindings/js/JSDirectoryEntryCustom.cpp:\n(WebCore::JSDirectoryEntry::getFile):\n(WebCore::JSDirectoryEntry::getDirectory):\n* bindings/js/JSSharedWorkerCustom.cpp:\n(WebCore::JSSharedWorkerConstructor::constructJSSharedWorker):\n* bindings/js/JSWebKitMutationObserverCustom.cpp:\n(WebCore::JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver):\n(WebCore::JSWebKitMutationObserver::observe):\n* bindings/js/JSWorkerCustom.cpp:\n(WebCore::JSWorkerConstructor::constructJSWorker):\n\n* bindings/scripts/test/JS/JSFloat64Array.cpp: Updated run-bindings-tests.\n(WebCore::jsFloat64ArrayPrototypeFunctionFoo):\n* bindings/scripts/test/JS/JSTestActiveDOMObject.cpp:\n(WebCore::jsTestActiveDOMObjectPrototypeFunctionExcitingFunction):\n(WebCore::jsTestActiveDOMObjectPrototypeFunctionPostMessage):\n* bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp:\n(WebCore::jsTestCustomNamedGetterPrototypeFunctionAnotherFunction):\n* bindings/scripts/test/JS/JSTestEventTarget.cpp:\n(WebCore::jsTestEventTargetPrototypeFunctionItem):\n(WebCore::jsTestEventTargetPrototypeFunctionAddEventListener):\n(WebCore::jsTestEventTargetPrototypeFunctionRemoveEventListener):\n(WebCore::jsTestEventTargetPrototypeFunctionDispatchEvent):\n* bindings/scripts/test/JS/JSTestInterface.cpp:\n(WebCore::JSTestInterfaceConstructor::constructJSTestInterface):\n(WebCore::jsTestInterfacePrototypeFunctionSupplementalMethod2):\n* bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp:\n(WebCore::jsTestMediaQueryListListenerPrototypeFunctionMethod):\n* bindings/scripts/test/JS/JSTestNamedConstructor.cpp:\n(WebCore::JSTestNamedConstructorNamedConstructor::constructJSTestNamedConstructor):\n* bindings/scripts/test/JS/JSTestObj.cpp:\n(WebCore::JSTestObjConstructor::constructJSTestObj):\n(WebCore::jsTestObjPrototypeFunctionVoidMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionIntMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionObjMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionMethodWithSequenceArg):\n(WebCore::jsTestObjPrototypeFunctionMethodReturningSequence):\n(WebCore::jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows):\n(WebCore::jsTestObjPrototypeFunctionSerializedValue):\n(WebCore::jsTestObjPrototypeFunctionIdbKey):\n(WebCore::jsTestObjPrototypeFunctionOptionsObject):\n(WebCore::jsTestObjPrototypeFunctionAddEventListener):\n(WebCore::jsTestObjPrototypeFunctionRemoveEventListener):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndTwoOptionalArgs):\n(WebCore::jsTestObjPrototypeFunctionMethodWithCallbackArg):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonCallbackArgAndCallbackArg):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod1):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod2):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod3):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod4):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod5):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod6):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod7):\n(WebCore::jsTestObjConstructorFunctionClassMethod2):\n(WebCore::jsTestObjConstructorFunctionOverloadedMethod11):\n(WebCore::jsTestObjConstructorFunctionOverloadedMethod12):\n(WebCore::jsTestObjPrototypeFunctionMethodWithUnsignedLongArray):\n(WebCore::jsTestObjPrototypeFunctionConvert1):\n(WebCore::jsTestObjPrototypeFunctionConvert2):\n(WebCore::jsTestObjPrototypeFunctionConvert3):\n(WebCore::jsTestObjPrototypeFunctionConvert4):\n(WebCore::jsTestObjPrototypeFunctionConvert5):\n(WebCore::jsTestObjPrototypeFunctionStrictFunction):\n* bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp:\n(WebCore::JSTestSerializedScriptValueInterfaceConstructor::constructJSTestSerializedScriptValueInterface):\n(WebCore::jsTestSerializedScriptValueInterfacePrototypeFunctionAcceptTransferList):\n\n\ngit-svn-id: svn://svn.chromium.org/blink/trunk@115536 bbb929c8-8fbe-4397-9dbb-9b2b20218538",
        "fixed_function": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->convert4();\n    return JSValue::encode(jsUndefined());\n}\n",
        "vul_function": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->convert4();\n    return JSValue::encode(jsUndefined());\n}\n",
        "llama3.1 Summary": "The patch replaces hardcoded error messages with the createNotEnoughArgumentsError function, improving maintainability and preventing potential errors due to incorrect or missing translations of hardcoded strings. This change was made to address a request by kbr@ in bug 84787 to avoid hard-coding error messages.",
        "llama3.1 CWE": "CWE-116",
        "llama3.1 CVE": "CVE-2011-4056",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5444",
            "BERTScore Recall": "0.5742",
            "BERTScore F1": "0.5589"
        },
        "llama3.1 Cosine_Similarity": 0.22231543064117432,
        "Mistral Summary": null,
        "Mistral CWE": "676 (Improper Control of Generated Code)\n\n   CVE ID: Not provided, as it's related to a specific version and implementation.\n\nThe commit shows multiple files in the WebKit project that have been updated to handle arguments for functions more consistently. This change aims to prevent issues such as the injection of malicious code or unintended behavior due to improper handling of function arguments. The CWE ID provided (676) is associated with \"Improper Control of Generated Code,\" which can lead to arbitrary code execution if user-supplied data is not properly validated and sanitized before being used in the generated code. By ensuring that all functions handle their arguments correctly, this commit reduces the risk of such vulnerabilities in the WebKit project.",
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.051917195320129395,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3465",
            "BERTScore Recall": "0.2608",
            "BERTScore F1": "0.2976"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0",
        "CVE ID": "CVE-2013-7294",
        "CVE Details": "The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.",
        "CWE ID": "CWE-20",
        "commit_message": "SECURITY: Properly handle IKEv2 I1 notification packet without KE payload",
        "fixed_function": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n\t\tchar fromname[ADDRTOT_BUF];\n\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\n\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n\t\t\t/* is this a notify? If so, log it */\n\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n\t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n\t\t\t\t\tenum_name(&ikev2_notify_names,\n\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n\t\t\t}\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",\n\t\t\t\tfromname, md->sender_port);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
        "vul_function": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3305",
            "BERTScore Recall": "0.2430",
            "BERTScore F1": "0.2801"
        },
        "llama3.1 Cosine_Similarity": 0.0678858757019043,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.0678858757019043,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3305",
            "BERTScore Recall": "0.2430",
            "BERTScore F1": "0.2801"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "CVE ID": "CVE-2013-7271",
        "CVE Details": "The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",
        "CWE ID": "CWE-20",
        "commit_message": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "fixed_function": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \n\t/* only handle MSG_DONTWAIT and MSG_PEEK */\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n",
        "vul_function": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n\tmsg->msg_namelen = 0;\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \n\t/* only handle MSG_DONTWAIT and MSG_PEEK */\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n",
        "llama3.1 Summary": "The patch fixes a bug where uninitialized memory was being leaked by not setting msg->msg_namelen to 0 in the recvmsg handler. This fix ensures that recvmsg handlers properly set msg_namelen, preventing potential leaks and making it harder for new code to introduce similar issues.",
        "llama3.1 CWE": "CWE-119",
        "llama3.1 CVE": "CVE-2022-4129",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5486",
            "BERTScore Recall": "0.5049",
            "BERTScore F1": "0.5259"
        },
        "llama3.1 Cosine_Similarity": 0.6153170466423035,
        "Mistral Summary": "The patch changes the handling of msg_namelen in the recvmsg function to always set it to 0, preventing uninitialized memory leaks. This change also optimizes for the case where recvfrom is called with a NULL address by setting msg->msg_name to NULL before invoking the recvmsg handler, and removes unnecessary curly brackets in ___sys_recvmsg.",
        "Mistral CWE": "CWE-178 (Buffer Error - Buffer Access)",
        "Mistral CVE": "Not provided, as CVEs are assigned by organizations such as MITRE and are not automatically assigned with code changes.",
        "Mistral Cosine_Similarity": 0.6952470541000366,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5883",
            "BERTScore Recall": "0.5664",
            "BERTScore F1": "0.5771"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/YanVugenfirer/kvm-guest-drivers-windows/commit/fbfa4d1083ea84c5429992ca3e996d7d4fbc8238",
        "CVE ID": "CVE-2015-3215",
        "CVE Details": "The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.",
        "CWE ID": "CWE-20",
        "commit_message": "NetKVM: BZ#1169718: More rigoruous testing of incoming packet\n\nSigned-off-by: Joseph Hindin <yhindin@rehat.com>",
        "fixed_function": " QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n {\n     tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n     UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n     UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n     USHORT ipHeaderSize = 0;\n     USHORT fullLength = 0;\n     res.value = 0;\n\n     if (ip_version == 4)\n     {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n         ipHeaderSize = (ver_len & 0xF) << 2;\n         fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n         res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n         {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || len < fullLength)\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n         }\n     }\n     else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        fullLength += ipHeaderSize;\n        while (nextHeader != 59)\n        {\n            IPv6ExtHeader *pExt;\n            switch (nextHeader)\n            {\n                case PROTOCOL_TCP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsTCP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case PROTOCOL_UDP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsUDP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case 0:\n                case 60:\n                case 43:\n                case 44:\n                case 51:\n                case 50:\n                case 135:\n                    if (len >= ((ULONG)ipHeaderSize + 8))\n                    {\n                        pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\n                        nextHeader = pExt->ip6ext_next_header;\n                        ipHeaderSize += 8;\n                        ipHeaderSize += pExt->ip6ext_hdr_len * 8;\n                    }\n                    else\n                    {\n                        DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\n                        res.ipStatus = ppresNotIP;\n                        bParsingDone = TRUE;\n                    }\n                    break;\n                default:\n                    res.xxpStatus = ppresXxpOther;\n                    bParsingDone = TRUE;\n                    break;\n            }\n            if (bParsingDone)\n                break;\n        }\n        if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n        {\n            DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n                ip_version, ipHeaderSize, nextHeader, fullLength));\n            res.ipHeaderSize = ipHeaderSize;\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n     if (res.ipStatus == ppresIPV4)\n     {\n         res.ipHeaderSize = ipHeaderSize;\n\n         res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n         switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:\n            {\n                res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        default:\n            res.xxpStatus = ppresXxpOther;\n            break;\n        }\n    }\n    return res;\n}\n",
        "vul_function": " QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n {\n     tTcpIpPacketParsingResult res;\n     UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n     UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n     USHORT ipHeaderSize = 0;\n     USHORT fullLength = 0;\n     res.value = 0;\n     if (ip_version == 4)\n     {\n         ipHeaderSize = (ver_len & 0xF) << 2;\n         fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));\n         res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;\n        if (fullLength) {}\n        else\n         {\n            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));\n         }\n     }\n     else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        fullLength += ipHeaderSize;\n        while (nextHeader != 59)\n        {\n            IPv6ExtHeader *pExt;\n            switch (nextHeader)\n            {\n                case PROTOCOL_TCP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsTCP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case PROTOCOL_UDP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsUDP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case 0:\n                case 60:\n                case 43:\n                case 44:\n                case 51:\n                case 50:\n                case 135:\n                    if (len >= ((ULONG)ipHeaderSize + 8))\n                    {\n                        pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\n                        nextHeader = pExt->ip6ext_next_header;\n                        ipHeaderSize += 8;\n                        ipHeaderSize += pExt->ip6ext_hdr_len * 8;\n                    }\n                    else\n                    {\n                        DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\n                        res.ipStatus = ppresNotIP;\n                        bParsingDone = TRUE;\n                    }\n                    break;\n                default:\n                    res.xxpStatus = ppresXxpOther;\n                    bParsingDone = TRUE;\n                    break;\n            }\n            if (bParsingDone)\n                break;\n        }\n        if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n        {\n            DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n                ip_version, ipHeaderSize, nextHeader, fullLength));\n            res.ipHeaderSize = ipHeaderSize;\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n     if (res.ipStatus == ppresIPV4)\n     {\n         res.ipHeaderSize = ipHeaderSize;\n        res.xxpFull = len >= fullLength ? 1 : 0;\n         res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n         switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:\n            {\n                res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        default:\n            res.xxpStatus = ppresXxpOther;\n            break;\n        }\n    }\n    return res;\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3307",
            "BERTScore Recall": "0.2651",
            "BERTScore F1": "0.2943"
        },
        "llama3.1 Cosine_Similarity": 0.07410919666290283,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.07410919666290283,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3307",
            "BERTScore Recall": "0.2651",
            "BERTScore F1": "0.2943"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/mdadams/jasper/commit/ba2b9d000660313af7b692542afbd374c5685865",
        "CVE ID": "CVE-2016-9390",
        "CVE Details": "The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.",
        "CWE ID": "CWE-20",
        "commit_message": "Ensure that not all tiles lie outside the image area.",
        "fixed_function": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n \tdec->tilexoff = siz->tilexoff;\n \tdec->tileyoff = siz->tileyoff;\n \tdec->numcomps = siz->numcomps;\n\n \tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n \t\treturn -1;\n \t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n",
        "vul_function": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n \tdec->tilexoff = siz->tilexoff;\n \tdec->tileyoff = siz->tileyoff;\n \tdec->numcomps = siz->numcomps;\n \tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n \t\treturn -1;\n \t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n",
        "llama3.1 Summary": null,
        "llama3.1 CWE": null,
        "llama3.1 CVE": null,
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3422",
            "BERTScore Recall": "0.2615",
            "BERTScore F1": "0.2964"
        },
        "llama3.1 Cosine_Similarity": 0.04812413454055786,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.04812413454055786,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3422",
            "BERTScore Recall": "0.2615",
            "BERTScore F1": "0.2964"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/3c8e4852477d5b1e2da877808c998dc57db9460f",
        "CVE ID": "CVE-2018-6111",
        "CVE Details": "An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.",
        "CWE ID": "CWE-20",
        "commit_message": "DevTools: speculative fix for crash in NetworkHandler::Disable\n\nThis keeps BrowserContext* and StoragePartition* instead of\nRenderProcessHost* in an attemp to resolve UAF of RenderProcessHost\nupon closure of DevTools front-end.\n\nBug: 801117, 783067, 780694\nChange-Id: I6c2cca60cc0c29f0949d189cf918769059f80c1b\nReviewed-on: https://chromium-review.googlesource.com/876657\nCommit-Queue: Andrey Kosyakov <caseq@chromium.org>\nReviewed-by: Dmitry Gozman <dgozman@chromium.org>\nCr-Commit-Position: refs/heads/master@{#531157}",
        "fixed_function": " void SharedWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  DCHECK(worker_host_);\n  state_ = WORKER_TERMINATED;\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(-1, nullptr);\n   worker_host_ = nullptr;\n   agent_ptr_.reset();\n }\n",
        "vul_function": " void SharedWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  DCHECK(worker_host_);\n  state_ = WORKER_TERMINATED;\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(nullptr, nullptr);\n   worker_host_ = nullptr;\n   agent_ptr_.reset();\n }\n",
        "llama3.1 Summary": "The patch removes a potential use-after-free error by changing the order of operations in the `SetRenderer` call, ensuring that the renderer is not set to null before setting it. This fix addresses the UAF vulnerability and prevents crashes reported in bugs 801117, 783067, and 780694.\n\nFixed version of function:  void SharedWorkerDevToolsAgentHost::WorkerDestroyed() {\n  DCHECK_NE(WORKER_TERMINATED, state_);\n  DCHECK(worker_host_);\n  state_ = WORKER_TERMINATED;\n   for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))\n     inspector->TargetCrashed();\n   for (DevToolsSession* session : sessions())\n    session->SetRenderer(-1, nullptr);\n   worker_host_ = nullptr;\n   agent_ptr_.reset();\n }",
        "llama3.1 CWE": "CWE-476",
        "llama3.1 CVE": "CVE-2017-5106",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.3590",
            "BERTScore Recall": "0.5580",
            "BERTScore F1": "0.4369"
        },
        "llama3.1 Cosine_Similarity": 0.4398106336593628,
        "Mistral Summary": "The patch changes the closure of DevTools front-end from using `RenderProcessHost*` to using `BrowserContext*` and `StoragePartition*`. This fix addresses a Use-After-Free (UAF) issue of `RenderProcessHost` upon its closure.",
        "Mistral CWE": "CWE-476 (Resource Leak)",
        "Mistral CVE": "CVE-YYYY-XXXX (Assuming a new CVE has been assigned for this vulnerability)",
        "Mistral Cosine_Similarity": 0.502295196056366,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5223",
            "BERTScore Recall": "0.5601",
            "BERTScore F1": "0.5405"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/0660e08731fd42076d7242068e9eaed1482b14d5",
        "CVE ID": "CVE-2019-5838",
        "CVE Details": "Insufficient policy enforcement in extensions API in Google Chrome prior to 75.0.3770.80 allowed an attacker who convinced a user to install a malicious extension to bypass restrictions on file URIs via a crafted Chrome Extension.",
        "CWE ID": "CWE-20",
        "commit_message": "Call CanCaptureVisiblePage in page capture API.\n\nCurrently the pageCapture permission allows access\nto arbitrary local files and chrome:// pages which\ncan be a security concern. In order to address this,\nthe page capture API needs to be changed similar to\nthe captureVisibleTab API. The API will now only allow\nextensions to capture otherwise-restricted URLs if the\nuser has granted activeTab. In addition, file:// URLs are\nonly capturable with the \"Allow on file URLs\" option enabled.\n\nBug: 893087\n\nChange-Id: I6d6225a3efb70fc033e2e1c031c633869afac624\nReviewed-on: https://chromium-review.googlesource.com/c/1330689\nCommit-Queue: Bettina Dea <bdea@chromium.org>\nReviewed-by: Devlin <rdevlin.cronin@chromium.org>\nReviewed-by: Varun Khaneja <vakh@chromium.org>\nCr-Commit-Position: refs/heads/master@{#615248}",
        "fixed_function": "  void ClearActiveTab() {\n  void ClearActiveTab(const Extension& extension) {\n    extension.permissions_data()->ClearTabSpecificPermissions(kTabId);\n   }\n",
        "vul_function": "  void ClearActiveTab() {\n    active_tab_->permissions_data()->ClearTabSpecificPermissions(kTabId);\n   }\n",
        "llama3.1 Summary": "The patch changes the ClearActiveTab function to take an Extension object as a parameter, which is then used to clear permissions data. This change was applied to address security concerns related to arbitrary local files and chrome:// pages being accessible due to the pageCapture permission. Fixed version of function:   void ClearActiveTab(const Extension& extension) {     extension.permissions_data()->ClearTabSpecificPermissions(kTabId); }",
        "llama3.1 CWE": "CWE-94",
        "llama3.1 CVE": "CVE-2019-12345",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.4735",
            "BERTScore Recall": "0.5259",
            "BERTScore F1": "0.4983"
        },
        "llama3.1 Cosine_Similarity": 0.5063275694847107,
        "Mistral Summary": "The patch changes to limit extension permissions in the page capture API, thereby preventing privilege escalation and reducing security concerns related to accessing arbitrary local files and chrome:// pages. The updated API now requires explicit user granting of activeTab permission for capturing otherwise-restricted URLs, and allows file:// URLs only when the \"Allow on file URLs\" option is enabled.",
        "Mistral CWE": "CWE-688 (Privilege Escalation)",
        "Mistral CVE": "CVE-XXXX-XXXX (Assigned by the responsible organization)",
        "Mistral Cosine_Similarity": 0.6104276776313782,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5394",
            "BERTScore Recall": "0.5334",
            "BERTScore F1": "0.5364"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/b944f670bb7a8a919daac497a4ea0536c954c201",
        "CVE ID": "CVE-2011-2350",
        "CVE Details": "The HTML parser in Google Chrome before 12.0.742.112 does not properly address \"lifetime and re-entrancy issues,\" which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "[JSC] Implement a helper method createNotEnoughArgumentsError()\nhttps://bugs.webkit.org/show_bug.cgi?id=85102\n\nReviewed by Geoffrey Garen.\n\nIn bug 84787, kbr@ requested to avoid hard-coding\ncreateTypeError(exec, \"Not enough arguments\") here and there.\nThis patch implements createNotEnoughArgumentsError(exec)\nand uses it in JSC bindings.\n\nc.f. a corresponding bug for V8 bindings is bug 85097.\n\nSource/JavaScriptCore:\n\n* runtime/Error.cpp:\n(JSC::createNotEnoughArgumentsError):\n(JSC):\n* runtime/Error.h:\n(JSC):\n\nSource/WebCore:\n\nTest: bindings/scripts/test/TestObj.idl\n\n* bindings/scripts/CodeGeneratorJS.pm: Modified as described above.\n(GenerateArgumentsCountCheck):\n\n* bindings/js/JSDataViewCustom.cpp: Ditto.\n(WebCore::getDataViewMember):\n(WebCore::setDataViewMember):\n* bindings/js/JSDeprecatedPeerConnectionCustom.cpp:\n(WebCore::JSDeprecatedPeerConnectionConstructor::constructJSDeprecatedPeerConnection):\n* bindings/js/JSDirectoryEntryCustom.cpp:\n(WebCore::JSDirectoryEntry::getFile):\n(WebCore::JSDirectoryEntry::getDirectory):\n* bindings/js/JSSharedWorkerCustom.cpp:\n(WebCore::JSSharedWorkerConstructor::constructJSSharedWorker):\n* bindings/js/JSWebKitMutationObserverCustom.cpp:\n(WebCore::JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver):\n(WebCore::JSWebKitMutationObserver::observe):\n* bindings/js/JSWorkerCustom.cpp:\n(WebCore::JSWorkerConstructor::constructJSWorker):\n\n* bindings/scripts/test/JS/JSFloat64Array.cpp: Updated run-bindings-tests.\n(WebCore::jsFloat64ArrayPrototypeFunctionFoo):\n* bindings/scripts/test/JS/JSTestActiveDOMObject.cpp:\n(WebCore::jsTestActiveDOMObjectPrototypeFunctionExcitingFunction):\n(WebCore::jsTestActiveDOMObjectPrototypeFunctionPostMessage):\n* bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp:\n(WebCore::jsTestCustomNamedGetterPrototypeFunctionAnotherFunction):\n* bindings/scripts/test/JS/JSTestEventTarget.cpp:\n(WebCore::jsTestEventTargetPrototypeFunctionItem):\n(WebCore::jsTestEventTargetPrototypeFunctionAddEventListener):\n(WebCore::jsTestEventTargetPrototypeFunctionRemoveEventListener):\n(WebCore::jsTestEventTargetPrototypeFunctionDispatchEvent):\n* bindings/scripts/test/JS/JSTestInterface.cpp:\n(WebCore::JSTestInterfaceConstructor::constructJSTestInterface):\n(WebCore::jsTestInterfacePrototypeFunctionSupplementalMethod2):\n* bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp:\n(WebCore::jsTestMediaQueryListListenerPrototypeFunctionMethod):\n* bindings/scripts/test/JS/JSTestNamedConstructor.cpp:\n(WebCore::JSTestNamedConstructorNamedConstructor::constructJSTestNamedConstructor):\n* bindings/scripts/test/JS/JSTestObj.cpp:\n(WebCore::JSTestObjConstructor::constructJSTestObj):\n(WebCore::jsTestObjPrototypeFunctionVoidMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionIntMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionObjMethodWithArgs):\n(WebCore::jsTestObjPrototypeFunctionMethodWithSequenceArg):\n(WebCore::jsTestObjPrototypeFunctionMethodReturningSequence):\n(WebCore::jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows):\n(WebCore::jsTestObjPrototypeFunctionSerializedValue):\n(WebCore::jsTestObjPrototypeFunctionIdbKey):\n(WebCore::jsTestObjPrototypeFunctionOptionsObject):\n(WebCore::jsTestObjPrototypeFunctionAddEventListener):\n(WebCore::jsTestObjPrototypeFunctionRemoveEventListener):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndTwoOptionalArgs):\n(WebCore::jsTestObjPrototypeFunctionMethodWithCallbackArg):\n(WebCore::jsTestObjPrototypeFunctionMethodWithNonCallbackArgAndCallbackArg):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod1):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod2):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod3):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod4):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod5):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod6):\n(WebCore::jsTestObjPrototypeFunctionOverloadedMethod7):\n(WebCore::jsTestObjConstructorFunctionClassMethod2):\n(WebCore::jsTestObjConstructorFunctionOverloadedMethod11):\n(WebCore::jsTestObjConstructorFunctionOverloadedMethod12):\n(WebCore::jsTestObjPrototypeFunctionMethodWithUnsignedLongArray):\n(WebCore::jsTestObjPrototypeFunctionConvert1):\n(WebCore::jsTestObjPrototypeFunctionConvert2):\n(WebCore::jsTestObjPrototypeFunctionConvert3):\n(WebCore::jsTestObjPrototypeFunctionConvert4):\n(WebCore::jsTestObjPrototypeFunctionConvert5):\n(WebCore::jsTestObjPrototypeFunctionStrictFunction):\n* bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp:\n(WebCore::JSTestSerializedScriptValueInterfaceConstructor::constructJSTestSerializedScriptValueInterface):\n(WebCore::jsTestSerializedScriptValueInterfacePrototypeFunctionAcceptTransferList):\n\n\ngit-svn-id: svn://svn.chromium.org/blink/trunk@115536 bbb929c8-8fbe-4397-9dbb-9b2b20218538",
        "fixed_function": "EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionExcitingFunction(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestActiveDOMObject::s_info))\n        return throwVMTypeError(exec);\n    JSTestActiveDOMObject* castedThis = jsCast<JSTestActiveDOMObject*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestActiveDOMObject::s_info);\n    if (!castedThis->allowsAccessFrom(exec))\n         return JSValue::encode(jsUndefined());\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     Node* nextChild(toNode(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->excitingFunction(nextChild);\n    return JSValue::encode(jsUndefined());\n}\n",
        "vul_function": "EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionExcitingFunction(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestActiveDOMObject::s_info))\n        return throwVMTypeError(exec);\n    JSTestActiveDOMObject* castedThis = jsCast<JSTestActiveDOMObject*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestActiveDOMObject::s_info);\n    if (!castedThis->allowsAccessFrom(exec))\n         return JSValue::encode(jsUndefined());\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     Node* nextChild(toNode(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->excitingFunction(nextChild);\n    return JSValue::encode(jsUndefined());\n}\n",
        "llama3.1 Summary": "The patch implements a helper method to create an error for not enough arguments, instead of hard-coding the error message in multiple places. This change improves code maintainability and reduces the risk of introducing errors due to hardcoded strings.",
        "llama3.1 CWE": "CWE-772",
        "llama3.1 CVE": "CVE-2011-4050",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5682",
            "BERTScore Recall": "0.5322",
            "BERTScore F1": "0.5496"
        },
        "llama3.1 Cosine_Similarity": 0.21728336811065674,
        "Mistral Summary": null,
        "Mistral CWE": null,
        "Mistral CVE": null,
        "Mistral Cosine_Similarity": 0.051917195320129395,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.3465",
            "BERTScore Recall": "0.2608",
            "BERTScore F1": "0.2976"
        },
        "Tokens Used": ""
    },
    {
        "codeLink": "https://github.com/chromium/chromium/commit/7352baf29ac44d23cd580c2edfa8faf4e140a480",
        "CVE ID": "CVE-2011-3965",
        "CVE Details": "Google Chrome before 17.0.963.46 does not properly check signatures, which allows remote attackers to cause a denial of service (application crash) via unspecified vectors.",
        "CWE ID": "CWE-20",
        "commit_message": "Fix null deref when walking cert chain.\n\nBUG=109664\nTEST=N/A\nReview URL: http://codereview.chromium.org/9150013\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@117080 0039d316-1c4b-4281-b951-d872f2087c98",
        "fixed_function": "void SignatureUtil::CheckSignature(\n    const FilePath& file_path,\n    ClientDownloadRequest_SignatureInfo* signature_info) {\n  VLOG(2) << \"Checking signature for \" << file_path.value();\n\n  WINTRUST_FILE_INFO file_info;\n  file_info.cbStruct = sizeof(file_info);\n  file_info.pcwszFilePath = file_path.value().c_str();\n  file_info.hFile = NULL;\n  file_info.pgKnownSubject = NULL;\n\n  WINTRUST_DATA wintrust_data;\n  wintrust_data.cbStruct = sizeof(wintrust_data);\n  wintrust_data.pPolicyCallbackData = NULL;\n  wintrust_data.pSIPClientData = NULL;\n  wintrust_data.dwUIChoice = WTD_UI_NONE;\n  wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;\n  wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n  wintrust_data.pFile = &file_info;\n  wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;\n  wintrust_data.hWVTStateData = NULL;\n  wintrust_data.pwszURLReference = NULL;\n  wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;\n  wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;\n\n  GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\n  LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                               &policy_guid,\n                               &wintrust_data);\n\n  CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(\n      wintrust_data.hWVTStateData);\n  if (prov_data) {\n    if (prov_data->csSigners > 0) {\n      signature_info->set_trusted(result == ERROR_SUCCESS);\n    }\n     for (DWORD i = 0; i < prov_data->csSigners; ++i) {\n       const CERT_CHAIN_CONTEXT* cert_chain_context =\n           prov_data->pasSigners[i].pChainContext;\n      if (!cert_chain_context)\n        break;\n       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {\n         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];\n         ClientDownloadRequest_CertificateChain* chain =\n             signature_info->add_certificate_chain();\n        if (!simple_chain)\n          break;\n         for (DWORD k = 0; k < simple_chain->cElement; ++k) {\n           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];\n           chain->add_element()->set_certificate(\n              element->pCertContext->pbCertEncoded,\n              element->pCertContext->cbCertEncoded);\n        }\n      }\n    }\n\n    wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                   &policy_guid, &wintrust_data);\n  }\n}\n",
        "vul_function": "void SignatureUtil::CheckSignature(\n    const FilePath& file_path,\n    ClientDownloadRequest_SignatureInfo* signature_info) {\n  VLOG(2) << \"Checking signature for \" << file_path.value();\n\n  WINTRUST_FILE_INFO file_info;\n  file_info.cbStruct = sizeof(file_info);\n  file_info.pcwszFilePath = file_path.value().c_str();\n  file_info.hFile = NULL;\n  file_info.pgKnownSubject = NULL;\n\n  WINTRUST_DATA wintrust_data;\n  wintrust_data.cbStruct = sizeof(wintrust_data);\n  wintrust_data.pPolicyCallbackData = NULL;\n  wintrust_data.pSIPClientData = NULL;\n  wintrust_data.dwUIChoice = WTD_UI_NONE;\n  wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;\n  wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n  wintrust_data.pFile = &file_info;\n  wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;\n  wintrust_data.hWVTStateData = NULL;\n  wintrust_data.pwszURLReference = NULL;\n  wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;\n  wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;\n\n  GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\n  LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                               &policy_guid,\n                               &wintrust_data);\n\n  CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(\n      wintrust_data.hWVTStateData);\n  if (prov_data) {\n    if (prov_data->csSigners > 0) {\n      signature_info->set_trusted(result == ERROR_SUCCESS);\n    }\n     for (DWORD i = 0; i < prov_data->csSigners; ++i) {\n       const CERT_CHAIN_CONTEXT* cert_chain_context =\n           prov_data->pasSigners[i].pChainContext;\n       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {\n         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];\n         ClientDownloadRequest_CertificateChain* chain =\n             signature_info->add_certificate_chain();\n         for (DWORD k = 0; k < simple_chain->cElement; ++k) {\n           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];\n           chain->add_element()->set_certificate(\n              element->pCertContext->pbCertEncoded,\n              element->pCertContext->cbCertEncoded);\n        }\n      }\n    }\n\n    wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                   &policy_guid, &wintrust_data);\n  }\n}\n",
        "llama3.1 Summary": "The patch fixes a null pointer dereference when walking the certificate chain by adding a check for NULL before accessing the cert_chain_context. This was applied to prevent a crash when dealing with malformed or incomplete certificate chains.",
        "llama3.1 CWE": "CWE-122",
        "llama3.1 CVE": "CVE-2012-5655",
        "llama3.1 BERT Score": {
            "BERTScore Precision": "0.5603",
            "BERTScore Recall": "0.5551",
            "BERTScore F1": "0.5577"
        },
        "llama3.1 Cosine_Similarity": 0.3432990312576294,
        "Mistral Summary": "The patch fixes a null dereference when walking the certificate chain. This vulnerability could have allowed an attacker to cause a crash or execute arbitrary code in certain conditions. The change ensures that iterations over the certificate chain only occur when a valid `CERT_CHAIN_CONTEXT` is found, preventing potential exploitation.",
        "Mistral CWE": "CWE-476",
        "Mistral CVE": "CVE-XXXX-XXXX (A unique identifier will be assigned by the appropriate organization)",
        "Mistral Cosine_Similarity": 0.353860080242157,
        "Mistral BERT Score": {
            "BERTScore Precision": "0.5494",
            "BERTScore Recall": "0.5858",
            "BERTScore F1": "0.5670"
        },
        "Tokens Used": ""
    }
]